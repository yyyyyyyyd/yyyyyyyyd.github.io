<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PageHelper的坑</title>
      <link href="/2023/03/09/PageHelper%E7%9A%84%E5%9D%91/"/>
      <url>/2023/03/09/PageHelper%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="PageHelper的坑"><a href="#PageHelper的坑" class="headerlink" title="PageHelper的坑"></a>PageHelper的坑</h1><p>当我们在使用 PageHelper.startPage 时，PageHelper <strong>会作用在它下面的第一行sql</strong>，而我们使用的initPage()其实也是PageHelper.startPage</p><p><img src="1.png" alt="image"></p><p>其原理就是把page信息放在了ThreadLocal中</p><p><img src="2.png" alt="image"></p><p>以下段代码为例：当我把线程数配置成1个时</p><p><img src="3.png" alt="image"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  tomcat:</span><br><span class="line">    uri-encoding: UTF-<span class="number">8</span></span><br><span class="line">    max-threads: <span class="number">1</span> #最大工作线程数量</span><br><span class="line">    min-spare-threads: <span class="number">1</span> #最小工作线程数量</span><br><span class="line">    #max-connections: <span class="number">10000</span> #一瞬间最大支持的并发的连接数</span><br><span class="line">    accept-count: <span class="number">1</span> #等待队列长度</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/getCommonDataListV2&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> TableResultResponse&lt;MyGetCommonDataListVO&gt; <span class="title function_">getCommonDataListV2</span><span class="params">(<span class="meta">@RequestBody</span> Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">        <span class="type">Dto</span> <span class="variable">dto</span> <span class="operator">=</span> Dtos.newDto(map);</span><br><span class="line">        Page&lt;Object&gt; result = initPage(dto);</span><br><span class="line">        </span><br><span class="line">        Page&lt;Object&gt; localPageBefore = PageHelper.getLocalPage();</span><br><span class="line">        System.out.println(<span class="string">&quot;before:&quot;</span> + localPageBefore);</span><br><span class="line"></span><br><span class="line">        List&lt;MyGetCommonDataListVO&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dto.getInteger(<span class="string">&quot;limit&quot;</span>) == <span class="number">5</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;555555555&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            list = baseBiz.getCommonDataListV2(dto);</span><br><span class="line">        &#125;</span><br><span class="line">        Page&lt;Object&gt; localPage = PageHelper.getLocalPage();</span><br><span class="line">        System.out.println(<span class="string">&quot;after:&quot;</span> + localPage);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TableResultResponse</span>&lt;&gt;(result.getTotal(),list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果传值 limit：5 ，那么该接口将不会执行sql 直接返回了一个空集合</p><p>如果我再接着调用下面这个接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/getCommonDataList&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> TableResultResponse&lt;MyGetCommonDataListVO&gt; <span class="title function_">getCommonDataList</span><span class="params">(<span class="meta">@RequestParam(&quot;parentId&quot;)</span> String parentId)</span> &#123;</span><br><span class="line">    Page&lt;Object&gt; localPageBefore = PageHelper.getLocalPage();</span><br><span class="line">    System.out.println(<span class="string">&quot;before:&quot;</span> + localPageBefore);</span><br><span class="line">    List&lt;MyGetCommonDataListVO&gt; list = baseBiz.getCommonDataList(parentId);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TableResultResponse</span>&lt;&gt;(list.size(),list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口并没有进行分页 ，但是 返回的数据 确实 5 条 ，被迫进行了分页</p><p>就是说原来要作用到getCommonDataListV2上接口的分页 反而作用到了 getCommonDataList 接口上面，导致数据错误。</p><p>大家感兴趣的可以测试上面的代码，进行复现。</p><p>以上总结：<strong>必须避免当使用了分页插件，但是sql未执行的情况</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《阿里巴巴代码编程规范（黄山版）》</title>
      <link href="/2023/03/07/%E3%80%8A%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%EF%BC%88%E9%BB%84%E5%B1%B1%E7%89%88%EF%BC%89%E3%80%8B/"/>
      <url>/2023/03/07/%E3%80%8A%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%EF%BC%88%E9%BB%84%E5%B1%B1%E7%89%88%EF%BC%89%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="PDF-预览"><a href="#PDF-预览" class="headerlink" title="PDF 预览"></a>PDF 预览</h3><div class="row">    <embed src="Java开发手册(黄山版).pdf" width="100%" height="550" type="application/pdf"></div><p>前言</p><p>《阿里巴巴Java开发手册》是阿里巴巴集团技术团队的集体智慧结晶和经验总</p><p>结，经历了多次大规模一线实战的检验及不断的完善，系统化地整理成册，反馈给广</p><p>大开发者。现代软件行业的高速发展对开发者的综合素质要求越来越高，因为不仅是</p><p>编程知识点，其它维度的知识点也会影响到软件的最终交付质量。比如：数据库的表</p><p>结构和索引设计缺陷可能带来软件上的架构缺陷或性能风险；工程结构混乱导致后续</p><p>维护艰难；没有鉴权的漏洞代码易被黑客攻击等等。所以本手册以Java开发者为中心</p><p>视角，划分为编程规约、异常日志、单元测试、安全规约、工程结构、MySQL数据库六</p><p>个维度，再根据内容特征，细分成若干二级子目录。根据约束力强弱及故障敏感性，</p><p>规约依次分为强制、推荐、参考三大类。对于规约条目的延伸信息中，“说明”对内</p><p>容做了适当扩展和解释；“正例”提倡什么样的编码和实现方式；“反例”说明需要</p><p>提防的雷区，以及真实的错误案例。</p><p>本手册的愿景是码出高效，码出质量。现代软件架构都需要协同开发完成，高效</p><p>协作即降低协同成本，提升沟通效率，所谓无规矩不成方圆，无规范不能协作。众所</p><p>周知，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全。试想如</p><p>果没有限速，没有红绿灯，谁还敢上路行驶。对软件来说，适当的规范和标准绝不是</p><p>消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式</p><p>一起做事，提升协作效率。代码的字里行间流淌的是软件生命中的血液，质量的提升</p><p>是尽可能少踩坑，杜绝踩重复的坑，切实提升质量意识。</p><p>考虑到可以零距离地与众多开发同学进行互动，决定在线维护《手册》内容，此</p><p>版本号为1.3.0的PDF版本，是对外释放的终极版；其次，我们会在 2017 年 10 月 14</p><p>日杭州云栖大会上，进行阿里巴巴Java开发规约插件全球首发，插件点此下载，阿里</p><p>巴巴云效（一站式企业协同研发云）也会集成代码规约扫描引擎。最后，《码出高效</p><p>——阿里巴巴Java开发手册详解》即将出版，敬请关注。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>一、编程规约 前言 </p></li><li><p>(一) 命名风格</p></li><li><p>(二) 常量定义</p></li><li><p>(三) 代码格式</p></li><li><p>(四) OOP规约</p></li><li><p>(五) 集合处理</p></li><li><p>(六) 并发处理</p></li><li><p>(七) 控制语句</p></li><li><p>(八) 注释规约</p></li><li><p>(九) 其它</p></li><li><p>二、异常日志 </p></li><li><p>(一) 异常处理</p></li><li><p>(二) 日志规约</p></li><li><p>三、单元测试</p></li><li><p>四、安全规约</p></li><li><p>五、MySQL数据库 </p></li><li><p>(一) 建表规约</p></li><li><p>(二) 索引规约</p></li><li><p>(三) SQL语句</p></li><li><p>(四) ORM映射</p></li><li><p>六、工程结构 </p></li><li><p>(一) 应用分层</p></li><li><p>(二) 二方库依赖</p></li><li><p>(三) 服务器</p></li><li><p>附 1 ：版本历史</p></li><li><p>附 2 ：本手册专有名词</p></li></ul><p>Java 开发手册</p><p>版本号 制定团队 更新日期 备注 1 .3.0 阿里巴巴集团技术团队 2017. 9. 25 增加单元测试规约（PDF终极版）</p><h2 id="一、编程规约"><a href="#一、编程规约" class="headerlink" title="一、编程规约"></a>一、编程规约</h2><h3 id="一-命名风格"><a href="#一-命名风格" class="headerlink" title="(一) 命名风格"></a>(一) 命名风格</h3><h4 id="1-【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。"><a href="#1-【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。" class="headerlink" title="1. 【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。"></a>1. 【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。</h4><p>反例：_name &#x2F; __name &#x2F; $Object &#x2F; name_ &#x2F; name$ &#x2F; Object$</p><ol start="4"><li><p>【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。正例：alibaba &#x2F; taobao &#x2F; youku &#x2F; hangzhou 等国际通用的名称，可视同英文。反例：DaZhePromotion [打折] &#x2F; getPingfenByName() [评分] &#x2F; int 某变量 &#x3D; 3</p></li><li><p>【强制】类名使用UpperCamelCase风格，必须遵从驼峰形式，但以下情形例外：DO &#x2F; BO &#x2F;DTO &#x2F; VO &#x2F; AO正例：MarcoPolo &#x2F; UserDO &#x2F; XmlService &#x2F; TcpUdpDeal &#x2F; TaPromotion反例：macroPolo &#x2F; UserDo &#x2F; XMLService &#x2F; TCPUDPDeal &#x2F; TAPromotion</p></li><li><p>【强制】方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵从驼峰形式。正例： localValue &#x2F; getHttpMessage() &#x2F; inputUserId</p></li><li><p>【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。正例：MAX_STOCK_COUNT反例：MAX_COUNT</p></li><li><p>【强制】抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类的名称开始，以Test结尾。</p></li><li><p>【强制】中括号是数组类型的一部分，数组定义如下：String[] args;反例：使用String args[]的方式来定义。</p></li><li><p>【强制】POJO类中布尔类型的变量，都不要加is，否则部分框架解析会引起序列化错误。反例：定义为基本数据类型Boolean isDeleted；的属性，它的方法也是isDeleted()，RPC</p></li></ol><p>     框架在反向解析的时候，“以为”对应的属性名称是deleted，导致属性获取不到，进而抛出异      常。</p><ol start="11"><li><p>【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。正例： 应用工具类包名为com.alibaba.open.util、类名为MessageUtils（此规则参考spring的框架结构） </p></li><li><p>【强制】杜绝完全不规范的缩写，避免望文不知义。反例：AbstractClass“缩写”命名成AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。 </p></li><li><p>【推荐】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。正例：从远程仓库拉取代码的类命名为PullCodeFromRemoteRepository。反例：变量int a; 的随意命名方式。 </p></li><li><p>【推荐】如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。正例：public class OrderFactory;public class LoginProxy;public class ResourceObserver; </p></li><li><p>【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。正例：接口方法签名：void f();接口基础常量表示：String COMPANY &#x3D; “alibaba”;反例：接口方法定义：public abstract void f();说明：JDK 8 中接口允许有默认实现，那么这个default方法，是对所有实现类都有价值的默认实现。 </p></li><li><p>接口和实现类的命名有两套规则：1 ）【强制】对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口，内部的实现类用Impl的后缀与接口区别。正例：CacheServiceImpl实现CacheService接口。2 ） 【推荐】 如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able的形式）。正例：AbstractTranslator实现 Translatable。 </p></li><li><p>【参考】枚举类名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。正例：枚举名字为ProcessStatusEnum的成员名称：SUCCESS &#x2F; UNKOWN_REASON。 </p></li><li><p>【参考】各层命名规约：A) Service&#x2F;DAO层方法命名规约1 ） 获取单个对象的方法用get做前缀。2 ） 获取多个对象的方法用list做前缀。3 ） 获取统计值的方法用count做前缀。4 ） 插入的方法用save&#x2F;insert做前缀。5 ） 删除的方法用remove&#x2F;delete做前缀。6 ） 修改的方法用update做前缀。B) 领域模型命名规约1 ） 数据对象：xxxDO，xxx即为数据表名。2 ） 数据传输对象：xxxDTO，xxx为业务领域相关的名称。3 ） 展示对象：xxxVO，xxx一般为网页名称。4 ） POJO是DO&#x2F;DTO&#x2F;BO&#x2F;VO的统称，禁止命名成xxxPOJO。</p></li></ol><p> </p><h3 id="二-常量定义"><a href="#二-常量定义" class="headerlink" title="(二) 常量定义"></a>(二) 常量定义</h3><h4 id="15-【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。"><a href="#15-【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。" class="headerlink" title="15. 【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。"></a>15. 【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。</h4><p>     反例：String key &#x3D; “Id#taobao_“ + tradeId;      cache.put(key, value);</p><ol start="19"><li><p>【强制】long或者Long初始赋值时，使用大写的L，不能是小写的l，小写容易跟数字 1 混淆，造成误解。说明：Long a &#x3D; 2l; 写的是数字的 21 ，还是Long型的2?</p></li><li><p>【推荐】不要使用一个常量类维护所有常量，按常量功能进行归类，分开维护。说明：大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。正例：缓存相关常量放在类CacheConsts下；系统配置相关常量放在类ConfigConsts下。</p></li><li><p>【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。1 ） 跨应用共享常量：放置在二方库中，通常是client.jar中的constant目录下。2 ） 应用内共享常量：放置在一方库中，通常是modules中的constant目录下。反例：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：</p></li></ol><p>类A中：public static final String YES &#x3D; “yes”; 类B中：public static final String YES &#x3D; “y”; A.YES.equals(B.YES)，预期是true，但实际返回为false，导致线上问题。 3 ） 子工程内部共享常量：即在当前子工程的constant目录下。 4 ） 包内共享常量：即在当前包下单独的constant目录下。 5 ） 类内共享常量：直接在类内部private static final定义。</p><ol start="22"><li>【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。下面正例中的数字就是延伸信息，表示星期几。正例：public Enum { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6),SUNDAY(7);}</li></ol><h3 id="三-代码格式"><a href="#三-代码格式" class="headerlink" title="(三) 代码格式"></a>(三) 代码格式</h3><h4 id="1-【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成-即可，不需要换行；如果"><a href="#1-【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成-即可，不需要换行；如果" class="headerlink" title="1. 【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果"></a>1. 【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果</h4><h4 id="是非空代码块则："><a href="#是非空代码块则：" class="headerlink" title="是非空代码块则："></a>是非空代码块则：</h4><h4 id="1-）-左大括号前不换行。"><a href="#1-）-左大括号前不换行。" class="headerlink" title="1 ） 左大括号前不换行。"></a>1 ） 左大括号前不换行。</h4><h4 id="2-）-左大括号后换行。"><a href="#2-）-左大括号后换行。" class="headerlink" title="2 ） 左大括号后换行。"></a>2 ） 左大括号后换行。</h4><h4 id="3-）-右大括号前换行。"><a href="#3-）-右大括号前换行。" class="headerlink" title="3 ） 右大括号前换行。"></a>3 ） 右大括号前换行。</h4><p>4 ） 右大括号后还有else等代码则不换行；表示终止的右大括号后必须换行。</p><ol start="23"><li><p>【强制】 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见第 5 条下方正例提示。反例：if (空格a &#x3D;&#x3D; b空格)</p></li><li><p>【强制】if&#x2F;for&#x2F;while&#x2F;switch&#x2F;do等保留字与括号之间都必须加空格。</p></li><li><p>【强制】任何二目、三目运算符的左右两边都需要加一个空格。说明：运算符包括赋值运算符&#x3D;、逻辑运算符&amp;&amp;、加减乘除符号等。</p></li><li><p>【强制】采用 4 个空格缩进，禁止使用tab字符。说明：如果使用tab缩进，必须设置 1 个tab为 4 个空格。IDEA设置tab为 4 个空格时，请勿勾选Use tab character；而在eclipse中，必须勾选insert spaces for tabs。正例： （涉及 1 - 5 点）public static void main(String[] args) {&#x2F;&#x2F; 缩进 4 个空格String say &#x3D; “hello”;&#x2F;&#x2F; 运算符的左右必须有一个空格int flag &#x3D; 0;</p></li></ol><p>&#x2F;&#x2F; 关键词if与括号之间必须有一个空格，括号内的f与左括号， 0 与右括号不需要空格 if (flag &#x3D;&#x3D; 0) { System.out.println(say); } &#x2F;&#x2F; 左大括号前加空格且不换行；左大括号后换行 if (flag &#x3D;&#x3D; 1) { System.out.println(“world”); &#x2F;&#x2F; 右大括号前换行，右大括号后有else，不用换行 } else { System.out.println(“ok”); &#x2F;&#x2F; 在右大括号后直接结束，则必须换行 } }</p><ol start="27"><li><p>【强制】注释的双斜线与注释内容之间有且仅有一个空格。正例：&#x2F;&#x2F; 注释内容，注意在&#x2F;&#x2F;和注释内容之间有一个空格。</p></li><li><p>【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：1 ） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。2 ） 运算符与下文一起换行。3 ） 方法调用的点符号与下文一起换行。4 ） 方法调用时，多个参数，需要换行时，在逗号后进行。5 ） 在括号前不要换行，见反例。正例：StringBuffer sb &#x3D; new StringBuffer();&#x2F;&#x2F; 超过 120 个字符的情况下，换行缩进 4 个空格，点号和方法名称一起换行sb.append(“zi”).append(“xin”)….append(“huang”)….append(“huang”)….append(“huang”);反例：StringBuffer sb &#x3D; new StringBuffer();&#x2F;&#x2F; 超过 120 个字符的情况下，不要在括号前换行sb.append(“zi”).append(“xin”)…append(“huang”);&#x2F;&#x2F; 参数很多的方法调用可能超过 120 个字符，不要在逗号前换行method(args1, args2, args3, …, argsX);</p></li><li><p>【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。正例：下例中实参的”a”,后边必须要有一个空格。method(“a”, “b”, “c”);</p></li><li><p>【强制】IDE的text file encoding设置为UTF- 8 ; IDE中文件的换行符使用Unix格式，不要使用Windows格式。</p></li></ol><h4 id="10-【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。"><a href="#10-【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。" class="headerlink" title="10. 【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。"></a>10. 【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。</h4><h4 id="正例："><a href="#正例：" class="headerlink" title="正例："></a>正例：</h4><p>int a &#x3D; 3; long b &#x3D; 4L; float c &#x3D; 5F; StringBuffer sb &#x3D; new StringBuffer(); 说明：增加sb这个变量，如果需要对齐，则给a、b、c都要增加几个空格，在变量比较多的 情况下，是一种累赘的事情。</p><ol start="31"><li>【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。说明：没有必要插入多个空行进行隔开。</li></ol><h3 id="四-OOP规约"><a href="#四-OOP规约" class="headerlink" title="(四) OOP规约"></a>(四) OOP规约</h3><h4 id="1-【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成"><a href="#1-【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成" class="headerlink" title="1. 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成"></a>1. 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成</h4><h4 id="本，直接用类名来访问即可。"><a href="#本，直接用类名来访问即可。" class="headerlink" title="本，直接用类名来访问即可。"></a>本，直接用类名来访问即可。</h4><ol start="32"><li><p>【强制】所有的覆写方法，必须加@Override注解。说明：getObject()与get 0 bject()的问题。一个是字母的O，一个是数字的 0 ，加<a href="/Override">@Override</a> 可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。</p></li><li><p>【强制】相同参数类型，相同业务含义，才可以使用Java的可变参数，避免使用Object。说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）正例：public User getUsers(String type, Integer… ids) {…}</p></li><li><p>【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated注解，并清晰地说明采用的新接口或者新服务是什么。</p></li><li><p>【强制】不能使用过时的类或方法。说明：java.net.URLDecoder 中的方法decode(String encodeStr) 这个方法已经过时，应该使用双参数decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。</p></li><li><p>【强制】Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。正例：”test”.equals(object);反例：object.equals(“test”);说明：推荐使用java.util.Objects#equals（JDK 7 引入的工具类）</p></li><li><p>【强制】所有的相同类型的包装类对象之间值的比较，全部使用equals方法比较。说明：对于Integer var &#x3D;? 在- 128 至 127 范围内的赋值，Integer对象是在</p></li></ol><p>IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用&#x3D;&#x3D;进行 判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑， 推荐使用equals方法进行判断。</p><ol start="38"><li><p>关于基本数据类型与包装数据类型的使用标准如下：1 ） 【强制】所有的POJO类属性必须使用包装数据类型。2 ） 【强制】RPC方法的返回值和参数必须使用包装数据类型。3 ） 【推荐】所有的局部变量使用基本数据类型。说明：POJO类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。正例：数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。反例：比如显示成交总额涨跌情况，即正负x%，x为基本数据类型，调用的RPC服务，调用不成功时，返回的是默认值，页面显示为0%，这是不合理的，应该显示成中划线。所以包装数据类型的null值，能够表示额外的信息，如：远程调用失败，异常退出。</p></li><li><p>【强制】定义DO&#x2F;DTO&#x2F;VO等POJO类时，不要设定任何属性默认值。反例：POJO类的gmtCreate默认值为new Date();但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。</p></li><li><p>【强制】序列化类新增属性时，请不要修改serialVersionUID字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改serialVersionUID值。说明：注意serialVersionUID不一致会抛出序列化运行时异常。</p></li><li><p>【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中。</p></li><li><p>【强制】POJO类必须写toString方法。使用IDE的中工具：source&gt; generate toString时，如果继承了另一个POJO类，注意在前面加一下super.toString。说明：在方法执行抛出异常时，可以直接调用POJO的toString()方法打印其属性值，便于排查问题。</p></li><li><p>【推荐】使用索引访问用String的split方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛IndexOutOfBoundsException的风险。说明：String str &#x3D; “a,b,c,,”;String[] ary &#x3D; str.split(“,”);&#x2F;&#x2F; 预期大于 3 ，结果是 3System.out.println(ary.length);</p></li><li><p>【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于第 15 条规则。</p></li><li><p>【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter&#x2F;setter方法。</p></li></ol><h4 id="说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类"><a href="#说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类" class="headerlink" title="说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类"></a>说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类</h4><h4 id="关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个"><a href="#关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个" class="headerlink" title="关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个"></a>关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个</h4><p>黑盒实现；因为承载的信息价值较低，所有Service和DAO的getter&#x2F;setter方法放在类体 最后。</p><ol start="46"><li><p>【推荐】setter方法中，参数名称与类成员变量名称一致，this.成员名 &#x3D; 参数名。在getter&#x2F;setter方法中，不要增加业务逻辑，增加排查问题的难度。反例：public Integer getData() {if (true) {return this.data + 100;} else {return this.data - 100;}}</p></li><li><p>【推荐】循环体内，字符串的连接方式，使用StringBuilder的append方法进行扩展。说明：反编译出的字节码文件显示每次循环都会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象，造成内存资源浪费。反例：String str &#x3D; “start”;for (int i &#x3D; 0; i &lt; 100; i++) {str &#x3D; str + “hello”;}</p></li><li><p>【推荐】final可以声明类、成员变量、方法、以及本地变量，下列情况使用final关键字：1 ） 不允许被继承的类，如：String类。2 ） 不允许修改引用的域对象，如：POJO类的域变量。3 ） 不允许被重写的方法，如：POJO类的setter方法。4 ） 不允许运行过程中重新赋值的局部变量。5 ） 避免上下文重复使用一个变量，使用final描述可以强制重新定义一个变量，方便更好地进行重构。</p></li><li><p>【推荐】慎用Object的clone方法来拷贝对象。说明：对象的clone方法默认是浅拷贝，若想实现深拷贝需要重写clone方法实现属性对象的拷贝。</p></li><li><p>【推荐】类成员与方法访问控制从严：1 ） 如果不允许外部直接通过new来创建对象，那么构造方法必须是private。2 ） 工具类不允许有public或default构造方法。3 ） 类非static成员变量并且与子类共享，必须是protected。4 ） 类非static成员变量并且仅在本类使用，必须是private。5 ） 类static成员变量如果仅在本类使用，必须是private。</p></li></ol><p>6 ） 若是static成员变量，必须考虑是否为final。 7 ） 类成员方法只供类内部调用，必须是private。 8 ） 类成员方法只对继承类公开，那么限制为protected。 说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。 思考：如果是一个private的方法，想删除就删除，可是一个public的service方法，或者 一个public的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的 视线内，变量作用域太大，无限制的到处跑，那么你会担心的。</p><h3 id="五-集合处理"><a href="#五-集合处理" class="headerlink" title="(五) 集合处理"></a>(五) 集合处理</h3><ol><li><p>【强制】关于hashCode和equals的处理，遵循如下规则：1 ） 只要重写equals，就必须重写hashCode。2 ） 因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法。3 ） 如果自定义对象做为Map的键，那么必须重写hashCode和equals。说明：String重写了hashCode和equals方法，所以我们可以非常愉快地使用String对象作为key来使用。</p></li><li><p>【强制】 ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException异常，即java.util.RandomAccessSubList cannot be cast to java.util.ArrayList.说明：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是ArrayList 的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。</p></li><li><p>【强制】在subList场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均会产生ConcurrentModificationException 异常。</p></li><li><p>【强制】使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的是类型完全一样的数组，大小就是list.size()。说明：使用toArray带参方法，入参分配的数组空间不够大时，toArray方法内部将重新分配内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组元素将被置为null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。正例：List list &#x3D; new ArrayList(2);list.add(“guan”);list.add(“bao”);String[] array &#x3D; new String[list.size()];array &#x3D; list.toArray(array);</p></li></ol><p>反例：直接使用toArray无参方法存在问题，此方法返回值只能是Object[]类，若强转其它 类型数组将出现ClassCastException错误。</p><ol start="5"><li><p>【强制】使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add&#x2F;remove&#x2F;clear方法会抛出UnsupportedOperationException异常。说明：asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。String[] str &#x3D; new String[] { “you”, “wu” };List list &#x3D; Arrays.asList(str);第一种情况：list.add(“yangguanbao”); 运行时异常。第二种情况：str[0] &#x3D; “gujin”; 那么list.get(0)也会随之修改。</p></li><li><p>【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用add方法，而&lt;? super T&gt;不能使用get方法，做为接口调用赋值时易出错。说明：扩展说一下PECS(Producer Extends Consumer Super)原则：第一、频繁往外读取内容的，适合用&lt;? extends T&gt;。第二、经常往里插入的，适合用&lt;? super T&gt;。</p></li><li><p>【强制】不要在foreach循环里进行元素的remove&#x2F;add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。正例：Iterator iterator &#x3D; list.iterator();while (iterator.hasNext()) {String item &#x3D; iterator.next();if (删除元素的条件) {iterator.remove();}}反例：List list &#x3D; new ArrayList();list.add(“1”);list.add(“2”);for (String item : list) {if (“1”.equals(item)) {list.remove(item);}}说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？</p></li><li><p>【强制】 在JDK 7 版本及以上，Comparator要满足如下三个条件，不然Arrays.sort，Collections.sort会报IllegalArgumentException异常。说明：三个条件如下1 ） x，y的比较结果和y，x的比较结果相反。</p></li></ol><p>2 ） x&gt;y，y&gt;z，则x&gt;z。 3 ） x&#x3D;y，则x，z比较结果和y，z比较结果相同。 反例：下例中没有处理相等的情况，实际使用中可能会出现异常： new Comparator<Student>() { @Override public int compare(Student o1, Student o2) { return o1.getId() &gt; o2.getId()? 1 : -1; } };</Student></p><ol start="9"><li><p>【推荐】集合初始化时，指定集合初始值大小。说明：HashMap使用HashMap(int initialCapacity) 初始化，正例：initialCapacity &#x3D; (需要存储的元素个数 &#x2F; 负载因子) + 1。注意负载因子（即loaderfactor）默认为0.75，如果暂时无法确定初始值大小，请设置为 16 （即默认值）。反例：HashMap需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫扩大，resize需要重建hash表，严重影响性能。</p></li><li><p>【推荐】使用entrySet遍历Map类集合KV，而不是keySet方式进行遍历。说明：keySet其实是遍历了 2 次，一次是转为Iterator对象，另一次是从hashMap中取出key所对应的value。而entrySet只是遍历了一次就把key和value都放到了entry中，效率更高。如果是JDK 8 ，使用Map.foreach方法。正例：values()返回的是V值集合，是一个list集合对象；keySet()返回的是K值集合，是一个Set集合对象；entrySet()返回的是K-V值组合集合。</p></li><li><p>【推荐】高度注意Map类集合K&#x2F;V能不能存储null值的情况，如下表格：</p></li></ol><p>集合类 Key Value Super 说明</p><p>Hashtable 不允许为null 不允许为null Dictionary 线程安全</p><p>ConcurrentHashMap 不允许为null 不允许为null AbstractMap 锁分段技术（JDK8:CAS）</p><p>TreeMap 不允许为null 允许为null AbstractMap 线程不安全</p><p>HashMap 允许为null^ 允许为null^ AbstractMap 线程不安全^</p><p>反例： 由于HashMap的干扰，很多人认为ConcurrentHashMap是可以置入null值，而事实上， 存储null值时会抛出NPE异常。</p><ol start="12"><li><p>【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。说明：有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。如：ArrayList是order&#x2F;unsort；HashMap是unorder&#x2F;unsort；TreeSet是order&#x2F;sort。 </p></li><li><p>【参考】利用Set元素唯一的特性，可以快速对一个集合进行去重操作，避免使用List的contains方法进行遍历、对比、去重操作。</p></li></ol><p> </p><h3 id="六-并发处理"><a href="#六-并发处理" class="headerlink" title="(六) 并发处理"></a>(六) 并发处理</h3><h4 id="1-【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。"><a href="#1-【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。" class="headerlink" title="1. 【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。"></a>1. 【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</h4><h4 id="说明：资源驱动类、工具类、单例工厂类都需要注意。"><a href="#说明：资源驱动类、工具类、单例工厂类都需要注意。" class="headerlink" title="说明：资源驱动类、工具类、单例工厂类都需要注意。"></a>说明：资源驱动类、工具类、单例工厂类都需要注意。</h4><h4 id="2-【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。"><a href="#2-【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。" class="headerlink" title="2. 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。"></a>2. 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</h4><h4 id="正例：-1"><a href="#正例：-1" class="headerlink" title="正例："></a>正例：</h4><p>public class TimerTaskThread extends Thread { public TimerTaskThread() { super.setName(“TimerTaskThread”); … }</p><ol start="14"><li><p>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p></li><li><p>【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。说明：Executors返回的线程池对象的弊端如下：1 ）FixedThreadPool和SingleThreadPool:允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。2 ）CachedThreadPool和ScheduledThreadPool:允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</p></li><li><p>【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。正例：注意线程安全，使用DateUtils。亦推荐如下处理：private static final ThreadLocal df &#x3D; new ThreadLocal() {<a href="/Override">@Override</a> protected DateFormat initialValue() {return new SimpleDateFormat(“yyyy-MM-dd”);}};说明：如果是JDK 8 的应用，可以使用Instant代替Date，LocalDateTime代替Calendar，DateTimeFormatter代替SimpleDateFormat，官方给出的解释：simple beautiful strongimmutable thread-safe。</p></li></ol><h4 id="6-【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能"><a href="#6-【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能" class="headerlink" title="6. 【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能"></a>6. 【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能</h4><h4 id="锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。"><a href="#锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。" class="headerlink" title="锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。"></a>锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</h4><h4 id="说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。"><a href="#说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。" class="headerlink" title="说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。"></a>说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。</h4><h4 id="7-【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造"><a href="#7-【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造" class="headerlink" title="7. 【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造"></a>7. 【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造</h4><h4 id="成死锁。"><a href="#成死锁。" class="headerlink" title="成死锁。"></a>成死锁。</h4><h4 id="说明：线程一需要对表A、B、C依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序"><a href="#说明：线程一需要对表A、B、C依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序" class="headerlink" title="说明：线程一需要对表A、B、C依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序"></a>说明：线程一需要对表A、B、C依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序</h4><h4 id="也必须是A、B、C，否则可能出现死锁。"><a href="#也必须是A、B、C，否则可能出现死锁。" class="headerlink" title="也必须是A、B、C，否则可能出现死锁。"></a>也必须是A、B、C，否则可能出现死锁。</h4><h4 id="8-【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加"><a href="#8-【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加" class="headerlink" title="8. 【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加"></a>8. 【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加</h4><p>锁，要么在数据库层使用乐观锁，使用version作为更新依据。 说明：如果每次访问冲突概率小于20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次 数不得小于 3 次。</p><ol start="17"><li><p>【强制】多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题。 </p></li><li><p>【推荐】使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法被执行到，避免主线程无法执行至await方法，直到超时才返回结果。说明：注意，子线程抛出异常堆栈，不能在主线程try-catch到。 </p></li><li><p>【推荐】避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。说明：Random实例包括java.util.Random 的实例或者 Math.random()的方式。正例：在JDK 7 之后，可以直接使用API ThreadLocalRandom，而在 JDK 7 之前，需要编码保证每个线程持有一个实例。 </p></li><li><p>【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration)，推荐解决方案中较为简单一种（适用于JDK 5 及以上版本），将目标属性声明为 volatile型。反例：class Singleton {private Helper helper &#x3D; null;public Helper getHelper() {if (helper &#x3D;&#x3D; null) synchronized(this) {if (helper &#x3D;&#x3D; null)helper &#x3D; new Helper();}return helper;}&#x2F;&#x2F; other methods and fields…} </p></li><li><p>【参考】volatile解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是count++操作，使用如下类实现：AtomicInteger count &#x3D; new AtomicInteger(); count.addAndGet( 1 ); 如果是JDK 8 ，推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）。 </p></li><li><p>【参考】 HashMap在容量不够进行resize时由于高并发可能出现死链，导致CPU飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。 </p></li><li><p>【参考】ThreadLocal无法解决共享对象的更新问题，ThreadLocal对象建议使用static修饰。这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。</p></li></ol><p> </p><h3 id="七-控制语句"><a href="#七-控制语句" class="headerlink" title="(七) 控制语句"></a>(七) 控制语句</h3><ol><li><p>【强制】在一个switch块内，每个case要么通过break&#x2F;return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch块内，都必须包含一个default语句并且放在最后，即使它什么代码也没有。</p></li><li><p>【强制】在if&#x2F;else&#x2F;for&#x2F;while&#x2F;do语句中必须使用大括号。即使只有一行代码，避免采用单行的编码方式：if (condition) statements;</p></li><li><p>【推荐】表达异常的分支时，少用if-else方式，这种方式可以改写成：if (condition) {…return obj;}&#x2F;&#x2F; 接着写else的业务逻辑代码;说明：如果非得使用if()…else if()…else…方式表达逻辑，【强制】避免后续代码维护困难，请勿超过 3 层。正例：超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句示例如下：public void today() {if (isBusy()) {System.out.println(“change time.”);return;}if (isFree()) {System.out.println(“go to travel.”);return;}</p></li></ol><p>System.out.println(“stay at home to learn Alibaba Java Coding Guidelines.”); return; }</p><ol start="4"><li><p>【推荐】除常用方法（如getXxx&#x2F;isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。说明：很多if语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？正例：&#x2F;&#x2F; 伪代码如下final boolean existed &#x3D; (file.open(fileName, “w”) !&#x3D; null) &amp;&amp; (…) || (…);if (existed) {…}反例：if ((file.open(fileName, “w”) !&#x3D; null) &amp;&amp; (…) || (…)) {…}</p></li><li><p>【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的try-catch操作（这个try-catch是否可以移至循环体外）。</p></li><li><p>【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。</p></li><li><p>【参考】下列情形，需要进行参数校验：1 ） 调用频次低的方法。2 ） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。3 ） 需要极高稳定性和可用性的方法。4 ） 对外提供的开放接口，不管是RPC&#x2F;API&#x2F;HTTP接口。5 ） 敏感权限入口。</p></li><li><p>【参考】下列情形，不需要进行参数校验：1 ） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。2 ） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般DAO层与Service层都在同一个应用中，部署在同一台服务器中，所以DAO的参数校验，可以省略。3 ） 被声明成private只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。</p></li></ol><h3 id="八-注释规约"><a href="#八-注释规约" class="headerlink" title="(八) 注释规约"></a>(八) 注释规约</h3><ol><li><p>【强制】类、类属性、类方法的注释必须使用Javadoc规范，使用&#x2F;**内容*&#x2F;格式，不得使用&#x2F;&#x2F; xxx方式。说明：在IDE编辑窗口中，Javadoc方式会提示相关注释，生成Javadoc可以正确输出相应注释；在IDE中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。</p></li><li><p>【强制】所有的抽象方法（包括接口中的方法）必须要用Javadoc注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。说明：对子类的实现要求，或者调用注意事项，请一并说明。</p></li><li><p>【强制】所有的类都必须添加创建者和创建日期。</p></li><li><p>【强制】方法内部单行注释，在被注释语句上方另起一行，使用&#x2F;&#x2F;注释。方法内部多行注释使用&#x2F; &#x2F;注释，注意与代码对齐。</p></li><li><p>【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。</p></li><li><p>【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。反例：“TCP连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。</p></li><li><p>【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。</p></li><li><p>【参考】谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。说明：代码被注释掉有两种可能性： 1 ）后续会恢复此段代码逻辑。 2 ）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。</p></li><li><p>【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。</p></li><li><p>【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。反例：&#x2F;&#x2F; put elephant into fridgeput(elephant, fridge);</p></li></ol><p>方法名put，加上两个有意义的变量名elephant和fridge，已经说明了这是在干什么，语 义清晰的代码不需要额外的注释。</p><ol start="11"><li>【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。1 ） 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]）表示需要实现，但目前还未实现的功能。这实际上是一个Javadoc的标签，目前的Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个Javadoc标签）。2 ） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）在注释中用FIXME标记某代码是错误的，而且不能工作，需要及时纠正的情况。</li></ol><h3 id="九-其它"><a href="#九-其它" class="headerlink" title="(九) 其它"></a>(九) 其它</h3><h4 id="1-【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。"><a href="#1-【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。" class="headerlink" title="1. 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。"></a>1. 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。</h4><p>说明：不要在方法体内定义：Pattern pattern &#x3D; Pattern.compile(规则);</p><ol start="12"><li><p>【强制】velocity调用POJO类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用POJO的getXxx()，如果是boolean基本数据类型变量（boolean命名不需要加is前缀），会自动调用isXxx()方法。说明：注意如果是Boolean包装类对象，优先调用getXxx()的方法。</p></li><li><p>【强制】后台输送给页面的变量必须加<img src="https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/7jP2lReDm42EO8g5/img/9cce1f54-97bf-4c4f-b40c-5e46552ef8c4" alt="image">{var}会直接显示在页面上。</p></li><li><p>【强制】注意 Math.random() 这个方法返回是double类型，注意取值的范围 0≤x&lt;1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将x放大 10 的若干倍然后取整，直接使用Random对象的nextInt或者nextLong方法。</p></li><li><p>【强制】获取当前毫秒数System.currentTimeMillis(); 而不是new Date().getTime();说明：如果想获取更加精确的纳秒级时间值，使用System.nanoTime()的方式。在JDK 8 中，针对统计时间等场景，推荐使用Instant类。</p></li><li><p>【推荐】不要在视图模板中加入任何复杂的逻辑。说明：根据MVC理论，视图的职责是展示，不要抢模型和控制器的活。</p></li><li><p>【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。</p></li><li><p>【推荐】及时清理不再使用的代码段或配置信息。说明：对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。正例：对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三</p></li></ol><h2 id="个斜杠-x2F-x2F-x2F-来说明注释掉代码的理由。"><a href="#个斜杠-x2F-x2F-x2F-来说明注释掉代码的理由。" class="headerlink" title="个斜杠(&#x2F;&#x2F;&#x2F;)来说明注释掉代码的理由。"></a>个斜杠(&#x2F;&#x2F;&#x2F;)来说明注释掉代码的理由。</h2><h2 id="二、异常日志"><a href="#二、异常日志" class="headerlink" title="二、异常日志"></a>二、异常日志</h2><h3 id="一-异常处理"><a href="#一-异常处理" class="headerlink" title="(一) 异常处理"></a>(一) 异常处理</h3><ol><li><p>【强制】Java 类库中定义的一类RuntimeException可以通过预先检查进行规避，而不应该通过catch 来处理，比如：IndexOutOfBoundsException，NullPointerException等等。说明：无法通过预检查的异常除外，如在解析一个外部传来的字符串形式数字时，通过catchNumberFormatException来实现。正例：if (obj !&#x3D; null) {…}反例：try { obj.method() } catch (NullPointerException e) {…}</p></li><li><p>【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。</p></li><li><p>【强制】对大段代码进行try-catch，这是不负责任的表现。catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。</p></li><li><p>【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</p></li><li><p>【强制】有try块放到了事务代码中，catch异常后，如果需要回滚事务，一定要注意手动回滚事务。</p></li><li><p>【强制】finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。说明：如果JDK 7 及以上，可以使用try-with-resources方式。</p></li><li><p>【强制】不能在finally块中使用return，finally块中的return返回后方法结束执行，不会再执行try块中的return语句。</p></li><li><p>【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。</p></li><li><p>【推荐】方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值。调用方需要进行null判断防止NPE问题。说明：本手册明确防止NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null的情况。</p></li><li><p>【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景：1 ）返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。反例：public int f() { return Integer对象}， 如果为null，自动解箱抛NPE。</p></li></ol><p>2 ） 数据库的查询结果可能为null。 3 ） 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。 4 ） 远程调用返回对象时，一律要求进行空指针判断，防止NPE。 5 ） 对于Session中获取的数据，建议NPE检查，避免空指针。 6 ） 级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。 正例：使用JDK8的Optional类来防止NPE问题。</p><ol start="11"><li><p>【推荐】定义时区分unchecked &#x2F; checked 异常，避免直接抛出new RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException &#x2F; ServiceException等。</p></li><li><p>【参考】在代码中使用“抛异常”还是“返回错误码”，对于公司外的http&#x2F;api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用Result方式，封装isSuccess()方法、“错误码”、“错误简短信息”。说明：关于RPC方法返回方式使用Result方式的理由：1 ）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。2 ）如果不加栈信息，只是new自定义异常，加入自己的理解的error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。</p></li><li><p>【参考】避免出现重复的代码（Don’t Repeat Yourself），即DRY原则。说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。正例：一个类中有多个public方法，都需要进行数行相同的参数校验操作，这个时候请抽取：private boolean checkParam(DTO dto) {…}</p></li></ol><h3 id="二-日志规约"><a href="#二-日志规约" class="headerlink" title="(二) 日志规约"></a>(二) 日志规约</h3><ol><li><p>【强制】应用中不可直接使用日志系统（Log 4 j、Logback）中的API，而应依赖使用日志框架SLF 4 J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static final Logger logger &#x3D; LoggerFactory.getLogger(Abc.class);</p></li><li><p>【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。</p></li><li><p>【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType:日志类型，推荐分类有stats&#x2F;desc&#x2F;monitor&#x2F;visit等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。</p></li></ol><p>正例：mppserver应用中单独监控时区转换异常，如： mppserver_monitor_timeZoneConvert.log 说明：推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于 通过日志对系统进行及时监控。</p><ol start="4"><li><p>【强制】对trace&#x2F;debug&#x2F;info级别的日志输出，必须使用条件输出形式或者使用占位符的方式。说明：logger.debug(“Processing trade with id: “ + id + “ and symbol: “ + symbol);如果日志级别是warn，上述日志不会打印，但是会执行字符串拼接操作，如果symbol是对象，会执行toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。正例：（条件）if (logger.isDebugEnabled()) {logger.debug(“Processing trade with id: “ + id + “ and symbol: “ + symbol);}正例：（占位符）logger.debug(“Processing trade with id: {} and symbol : {} “, id, symbol);</p></li><li><p>【强制】避免重复打印日志，浪费磁盘空间，务必在log 4 j.xml中设置additivity&#x3D;false。正例：</p></li><li><p>【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字throws往上抛出。正例：logger.error(各类参数或者对象toString + “_“ + e.getMessage(), e);</p></li><li><p>【推荐】谨慎地记录日志。生产环境禁止输出debug日志；有选择地输出info日志；如果使用warn来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？</p></li><li><p>【参考】可以使用warn日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别，error级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出error级别。</p></li></ol><h2 id="三、单元测试"><a href="#三、单元测试" class="headerlink" title="三、单元测试"></a>三、单元测试</h2><h4 id="1-【强制】好的单元测试必须遵守AIR原则。"><a href="#1-【强制】好的单元测试必须遵守AIR原则。" class="headerlink" title="1. 【强制】好的单元测试必须遵守AIR原则。"></a>1. 【强制】好的单元测试必须遵守AIR原则。</h4><h4 id="说明：单元测试在线上运行时，感觉像空气（AIR）一样并不存在，但在测试质量的保障上，"><a href="#说明：单元测试在线上运行时，感觉像空气（AIR）一样并不存在，但在测试质量的保障上，" class="headerlink" title="说明：单元测试在线上运行时，感觉像空气（AIR）一样并不存在，但在测试质量的保障上，"></a>说明：单元测试在线上运行时，感觉像空气（AIR）一样并不存在，但在测试质量的保障上，</h4><h4 id="却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。"><a href="#却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。" class="headerlink" title="却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。"></a>却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。</h4><p> A：Automatic（自动化）  I：Independent（独立性）  R：Repeatable（可重复）</p><ol start="9"><li><p>【强制】单元测试应该是全自动执行的，并且非交互式的。测试框架通常是定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用System.out来进行人肉验证，必须使用assert来验证。</p></li><li><p>【强制】保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。反例：method2需要依赖method1的执行，将执行结果做为method2的输入。</p></li><li><p>【强制】单元测试是可以重复执行的，不能受到外界环境的影响。说明：单元测试通常会被放到持续集成中，每次有代码check in时单元测试都会被执行。如果单测对外部环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。正例：为了不受外界环境影响，要求设计代码时就把SUT的依赖改成注入，在测试时用spring这样的DI框架注入一个本地（内存）实现或者Mock实现。</p></li><li><p>【强制】对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。说明：只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑，那是集成测试的领域。</p></li><li><p>【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过。说明：新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。</p></li><li><p>【强制】单元测试代码必须写在如下工程目录：src&#x2F;test&#x2F;java，不允许写在业务代码目录下。说明：源码构建时会跳过此目录，而单元测试框架默认是扫描此目录。</p></li><li><p>【推荐】单元测试的基本目标：语句覆盖率达到70%；核心模块的语句覆盖率和分支覆盖率都要达到100%说明：在工程规约的应用分层中提到的DAO层，Manager层，可重用度高的Service，都应该进行单元测试。</p></li></ol><h4 id="9-【推荐】编写单元测试代码遵守BCDE原则，以保证被测试模块的交付质量。"><a href="#9-【推荐】编写单元测试代码遵守BCDE原则，以保证被测试模块的交付质量。" class="headerlink" title="9. 【推荐】编写单元测试代码遵守BCDE原则，以保证被测试模块的交付质量。"></a>9. 【推荐】编写单元测试代码遵守BCDE原则，以保证被测试模块的交付质量。</h4><p> B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。  C：Correct，正确的输入，并得到预期的结果。  D：Design，与设计文档相结合，来编写单元测试。  E：Error，强制错误信息输入（如：非法数据、异常流程、非业务允许输入等），并得 到预期的结果。</p><ol start="16"><li><p>【推荐】对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。反例：删除某一行数据的单元测试，在数据库中，先直接手动增加一行作为删除目标，但是这一行新增数据并不符合业务插入规则，导致测试结果异常。</p></li><li><p>【推荐】和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。正例：在RDC内部单元测试中，使用RDC_UNIT_TEST_的前缀标识数据。</p></li><li><p>【推荐】对于不可测的代码建议做必要的重构，使代码变得可测，避免为了达到测试要求而书写不规范测试代码。</p></li><li><p>【推荐】在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好覆盖所有测试用例（UC）。</p></li><li><p>【推荐】单元测试作为一种质量保障手段，不建议项目发布后补充单元测试用例，建议在项目提测前完成单元测试。</p></li><li><p>【参考】为了更方便地进行单元测试，业务代码应避免以下情况：</p></li></ol><p> 构造方法中做的事情过多。  存在过多的全局变量和静态方法。  存在过多的外部依赖。  存在过多的条件语句。 说明：多层条件语句建议使用卫语句、策略模式、状态模式等方式重构。</p><ol start="22"><li>【参考】不要对单元测试存在如下误解：</li></ol><p> 那是测试同学干的事情。本文是开发手册，凡是本文内容都是与开发同学强相关的。  单元测试代码是多余的。汽车的整体功能与各单元部件的测试正常与否是强相关的。  单元测试代码不需要维护。一年半载后，那么单元测试几乎处于废弃状态。  单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障。</p><h2 id="四、安全规约"><a href="#四、安全规约" class="headerlink" title="四、安全规约"></a>四、安全规约</h2><h4 id="1-【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。"><a href="#1-【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。" class="headerlink" title="1. 【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。"></a>1. 【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。</h4><h4 id="说明：防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信"><a href="#说明：防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信" class="headerlink" title="说明：防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信"></a>说明：防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信</h4><h4 id="内容、修改他人的订单。"><a href="#内容、修改他人的订单。" class="headerlink" title="内容、修改他人的订单。"></a>内容、修改他人的订单。</h4><h4 id="2-【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。"><a href="#2-【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。" class="headerlink" title="2. 【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。"></a>2. 【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。</h4><h4 id="说明：查看个人手机号码会显示成-1-58-9119，隐藏中间-4-位，防止隐私泄露。"><a href="#说明：查看个人手机号码会显示成-1-58-9119，隐藏中间-4-位，防止隐私泄露。" class="headerlink" title="说明：查看个人手机号码会显示成:1 58 9119，隐藏中间 4 位，防止隐私泄露。"></a>说明：查看个人手机号码会显示成:1 58 9119，隐藏中间 4 位，防止隐私泄露。</h4><h4 id="3-【强制】用户输入的SQL参数严格使用参数绑定或者METADATA字段值限定，防止SQL注入，"><a href="#3-【强制】用户输入的SQL参数严格使用参数绑定或者METADATA字段值限定，防止SQL注入，" class="headerlink" title="3. 【强制】用户输入的SQL参数严格使用参数绑定或者METADATA字段值限定，防止SQL注入，"></a>3. 【强制】用户输入的SQL参数严格使用参数绑定或者METADATA字段值限定，防止SQL注入，</h4><h4 id="禁止字符串拼接SQL访问数据库。"><a href="#禁止字符串拼接SQL访问数据库。" class="headerlink" title="禁止字符串拼接SQL访问数据库。"></a>禁止字符串拼接SQL访问数据库。</h4><h4 id="4-【强制】用户请求传入的任何参数必须做有效性验证。"><a href="#4-【强制】用户请求传入的任何参数必须做有效性验证。" class="headerlink" title="4. 【强制】用户请求传入的任何参数必须做有效性验证。"></a>4. 【强制】用户请求传入的任何参数必须做有效性验证。</h4><h4 id="说明：忽略参数校验可能导致："><a href="#说明：忽略参数校验可能导致：" class="headerlink" title="说明：忽略参数校验可能导致："></a>说明：忽略参数校验可能导致：</h4><p> page size过大导致内存溢出  恶意order by导致数据库慢查询  任意重定向  SQL注入  反序列化注入  正则输入源串拒绝服务ReDoS 说明：Java代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题， 但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。</p><ol start="23"><li><p>【强制】禁止向HTML页面输出未经安全过滤或未正确转义的用户数据。</p></li><li><p>【强制】表单、AJAX提交必须执行CSRF安全过滤。说明：CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在CSRF漏洞的应用&#x2F;网站，攻击者可以事先构造好URL，只要受害者用户一访问，后台便在用户不知情情况下对数据库中用户参数进行相应修改。</p></li><li><p>【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制，如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费。</p></li><li><p>【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。</p></li></ol><h2 id="五、MySQL数据库"><a href="#五、MySQL数据库" class="headerlink" title="五、MySQL数据库"></a>五、MySQL数据库</h2><h3 id="一-建表规约"><a href="#一-建表规约" class="headerlink" title="(一) 建表规约"></a>(一) 建表规约</h3><ol><li><p>【强制】表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint（ 1 表示是， 0 表示否）。说明：任何字段如果为非负数，必须是unsigned。正例：表达逻辑删除的字段名is_deleted， 1 表示删除， 0 表示未删除。</p></li><li><p>【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。说明：MySQL在Windows下不区分大小写，但在Linux下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。正例：aliyun_admin，rdc_config，level3_name反例：AliyunAdmin，rdcConfig，level_3_name</p></li><li><p>【强制】表名不使用复数名词。说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。</p></li><li><p>【强制】禁用保留字，如desc、range、match、delayed等，请参考MySQL官方保留字。</p></li><li><p>【强制】主键索引名为pk_字段名；唯一索引名为uk_字段名；普通索引名则为idx_字段名。说明：pk <em>即primary key；uk</em> 即 unique key；idx_ 即index的简称。</p></li><li><p>【强制】小数类型为decimal，禁止使用float和double。说明：float和double在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成整数和小数分开存储。</p></li><li><p>【强制】如果存储的字符串长度几乎相等，使用char定长字符串类型。</p></li><li><p>【强制】varchar是可变长字符串，不预先分配存储空间，长度不要超过 5000 ，如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p></li><li><p>【强制】表必备三字段：id, gmt_create, gmt_modified。说明：其中id必为主键，类型为unsigned bigint、单表时自增、步长为 1 。gmt_create,gmt_modified的类型均为date_time类型，前者现在时表示主动创建，后者过去分词表示被动更新。</p></li><li><p>【推荐】表的命名最好是加上“业务名称_表的作用”。正例：alipay_task &#x2F; force_project &#x2F; trade_config</p></li></ol><h4 id="11-【推荐】库名与应用名称尽量一致。"><a href="#11-【推荐】库名与应用名称尽量一致。" class="headerlink" title="11. 【推荐】库名与应用名称尽量一致。"></a>11. 【推荐】库名与应用名称尽量一致。</h4><h4 id="12-【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。"><a href="#12-【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。" class="headerlink" title="12. 【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。"></a>12. 【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。</h4><h4 id="13-【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循："><a href="#13-【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：" class="headerlink" title="13. 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循："></a>13. 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：</h4><h4 id="1-）不是频繁修改的字段。"><a href="#1-）不是频繁修改的字段。" class="headerlink" title="1 ）不是频繁修改的字段。"></a>1 ）不是频繁修改的字段。</h4><p>2 ）不是varchar超长字段，更不能是text字段。 正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存 储类目名称，避免关联查询。</p><ol start="11"><li><p>【推荐】单表行数超过 500 万行或者单表容量超过 2 GB，才推荐进行分库分表。说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p></li><li><p>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。</p></li></ol><p>对象 年龄区间 类型 字节 表示范围 人 150 岁之内 unsigned tinyint 1 无符号值： 0 到 255 龟 数百岁 unsigned smallint 2 无符号值： 0 到 65535 恐龙化石 数千万年 unsigned int 4 无符号值： 0 到约42.9亿 太阳 约 50 亿年 unsigned bigint 8 无符号值： 0 到约 10 的 19 次方</p><h3 id="二-索引规约"><a href="#二-索引规约" class="headerlink" title="(二) 索引规约"></a>(二) 索引规约</h3><h4 id="1-【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。"><a href="#1-【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。" class="headerlink" title="1. 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。"></a>1. 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。</h4><p>说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明 显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必 然有脏数据产生。</p><ol start="13"><li><p>【强制】超过三个表禁止join。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。说明：即使双表join也要注意表索引、SQL性能。</p></li><li><p>【强制】在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分</p></li></ol><p>度会高达90%以上，可以使用count(distinct left(列名, 索引长度))&#x2F;count(*)的区分度 来确定。</p><ol start="15"><li><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。说明：索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p></li><li><p>【推荐】如果有order by的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。正例：where a&#x3D;? and b&#x3D;? order by c; 索引：a_b_c反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b; 索引a_b无法排序。</p></li><li><p>【推荐】利用覆盖索引来进行查询操作，避免回表。说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。正例：能够建立索引的种类：主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种效果，用explain的结果，extra列会出现：using index。</p></li><li><p>【推荐】利用延迟关联或者子查询优化超多分页场景。说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。正例：先快速定位需要获取的id段，然后再关联：SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id&#x3D;b.id</p></li><li><p>【推荐】 SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。说明：1 ）consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。2 ）ref 指的是使用普通的索引（normal index）。3 ）range 对索引进行范围检索。反例：explain表的结果，type&#x3D;index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。</p></li><li><p>【推荐】建组合索引的时候，区分度最高的在最左边。正例：如果where a&#x3D;? and b&#x3D;? ，a列的几乎接近于唯一值，那么只需要单建idx_a索引即可。说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a&gt;?and b&#x3D;? 那么即使a的区分度更高，也必须把b放在索引的最前列。</p></li></ol><h4 id="10-【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。"><a href="#10-【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。" class="headerlink" title="10. 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。"></a>10. 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。</h4><h4 id="11-【参考】创建索引时避免有如下极端误解："><a href="#11-【参考】创建索引时避免有如下极端误解：" class="headerlink" title="11. 【参考】创建索引时避免有如下极端误解："></a>11. 【参考】创建索引时避免有如下极端误解：</h4><h4 id="1-）宁滥勿缺。认为一个查询就需要建一个索引。"><a href="#1-）宁滥勿缺。认为一个查询就需要建一个索引。" class="headerlink" title="1 ）宁滥勿缺。认为一个查询就需要建一个索引。"></a>1 ）宁滥勿缺。认为一个查询就需要建一个索引。</h4><h4 id="2-）宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。"><a href="#2-）宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。" class="headerlink" title="2 ）宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。"></a>2 ）宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。</h4><h4 id="3-）抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。"><a href="#3-）抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。" class="headerlink" title="3 ）抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。"></a>3 ）抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</h4><h3 id="三-SQL语句"><a href="#三-SQL语句" class="headerlink" title="(三) SQL语句"></a>(三) SQL语句</h3><ol><li><p>【强制】不要使用count(列名)或count(常量)来替代count(<em>)，count(</em>)是SQL 92 定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关。说明：count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。 </p></li><li><p>【强制】count(distinct col) 计算该列除NULL之外的不重复行数，注意 count(distinctcol1, col 2 ) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为 0 。 </p></li><li><p>【强制】当某一列的值全是NULL时，count(col)的返回结果为 0 ，但sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题。正例：可以使用如下方式来避免sum的NPE问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g))FROM table; </p></li><li><p>【强制】使用ISNULL()来判断是否为NULL值。说明：NULL与任何值的直接比较都为NULL。1 ） NULL&lt;&gt;NULL的返回结果是NULL，而不是false。2 ） NULL&#x3D;NULL的返回结果是NULL，而不是true。3 ） NULL&lt;&gt;1的返回结果是NULL，而不是true。 </p></li><li><p>【强制】 在代码中写分页查询逻辑时，若count为 0 应直接返回，避免执行后面的分页语句。 </p></li><li><p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。说明：以学生和成绩的关系为例，学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学生表中的student_id，同时触发成绩表中的student_id更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 </p></li><li><p>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 </p></li><li><p>【强制】数据订正时，删除和修改记录时，要先select，避免出现误删除，确认无误才能执行更新语句。 </p></li><li><p>【推荐】in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在 1000 个之内。 </p></li><li><p>【参考】如果有全球化需要，所有的字符存储与表示，均以utf- 8 编码，注意字符统计函数的区别。说明：SELECT LENGTH(“轻松工作”)； 返回为 12SELECT CHARACTER_LENGTH(“轻松工作”)； 返回为 4如果需要存储表情，那么选择utfmb 4 来进行存储，注意它与utf- 8 编码的区别。 </p></li><li><p>【参考】 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但TRUNCATE无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句。说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p></li></ol><p> </p><h3 id="四-ORM映射"><a href="#四-ORM映射" class="headerlink" title="(四) ORM映射"></a>(四) ORM映射</h3><h4 id="1-【强制】在表查询中，一律不要使用-作为查询的字段列表，需要哪些字段必须明确写明。"><a href="#1-【强制】在表查询中，一律不要使用-作为查询的字段列表，需要哪些字段必须明确写明。" class="headerlink" title="1. 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。"></a>1. 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。</h4><p>说明： 1 ）增加查询分析器解析成本。 2 ）增减字段容易与resultMap配置不一致。</p><ol start="12"><li><p>【强制】POJO类的布尔属性不能加is，而数据库字段必须加is_，要求在resultMap中进行字段与属性之间的映射。说明：参见定义POJO类以及数据库字段定义规定，在中增加映射，是必须的。在MyBatis Generator生成的代码中，需要进行对应的修改。 </p></li><li><p>【强制】不要用resultClass当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。说明：配置映射关系，使字段与DO类解耦，方便维护。 </p></li><li><p>【强制】sql.xml配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现SQL注入。 </p></li><li><p>【强制】iBATIS自带的queryForList(String statementName,int start,int size)不推荐使用。说明：其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList取start,size的子集合。正例：Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;String, Object&gt;();map.put(“start”, start);map.put(“size”, size); </p></li><li><p>【强制】不允许直接拿HashMap与Hashtable作为查询结果集的输出。说明：resultClass&#x3D;”Hashtable”，会置入字段名和属性值，但是值的类型不可控。 </p></li><li><p>【强制】更新数据表记录时，必须同时更新记录对应的gmt_modified字段值为当前时间。 </p></li><li><p>【推荐】不要写一个大而全的数据更新接口。传入为POJO类，不管是不是自己的目标更新字段，都进行update table set c1&#x3D;value1,c2&#x3D;value2,c3&#x3D;value3; 这是不对的。执行SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加binlog存储。 </p></li><li><p>【参考】@Transactional事务不要滥用。事务会影响数据库的QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。 </p></li><li><p>【参考】中的compareValue是与属性值对比的常量，一般是数字，表示相等时带上此条件；表示不为空且不为null时执行；表示不为null值时</p></li></ol><p> </p><h2 id="执行。"><a href="#执行。" class="headerlink" title="执行。"></a>执行。</h2><h2 id="六、工程结构"><a href="#六、工程结构" class="headerlink" title="六、工程结构"></a>六、工程结构</h2><h3 id="一-应用分层"><a href="#一-应用分层" class="headerlink" title="(一) 应用分层"></a>(一) 应用分层</h3><h4 id="1-【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于"><a href="#1-【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于" class="headerlink" title="1. 【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于"></a>1. 【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于</h4><p>Web层，也可以直接依赖于Service层，依此类推：</p><p> 开放接口层：可直接封装Service方法暴露成RPC接口；通过Web封装成http接口；进行 网关安全控制、流量控制等。  终端显示层：各个端的模板渲染并执行显示的层。当前主要是velocity渲染，JS渲染， JSP渲染，移动端展示等。  Web层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。  Service层：相对具体的业务逻辑服务层。  Manager层：通用业务处理层，它有如下特征： 1 ） 对第三方平台封装的层，预处理返回结果及转化异常信息； 2 ） 对Service层通用能力的下沉，如缓存方案、中间件通用处理； 3 ） 与DAO层交互，对多个DAO的组合复用。  DAO层：数据访问层，与底层MySQL、Oracle、Hbase等进行数据交互。  外部接口或第三方平台：包括其它部门RPC开放接口，基础平台，其它公司的HTTP接口。</p><ol start="21"><li>【参考】 （分层异常处理规约）在DAO层，产生的异常类型有很多，无法用细粒度的异常进行catch，使用catch(Exception e)方式，并throw new DAOException(e)，不需要打印日志，因为日志在Manager&#x2F;Service层一定需要捕获并打到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在Service层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果Manager层与Service同机部署，日志方式与DAO层处理一致，如果是单独部署，则采用与Service一致的处理方式。Web层绝不应该继续往上</li></ol><h4 id="抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接"><a href="#抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接" class="headerlink" title="抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接"></a>抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接</h4><h4 id="跳转到友好错误页面，加上用户容易理解的错误提示信息。开放接口层要将异常处理成错误码"><a href="#跳转到友好错误页面，加上用户容易理解的错误提示信息。开放接口层要将异常处理成错误码" class="headerlink" title="跳转到友好错误页面，加上用户容易理解的错误提示信息。开放接口层要将异常处理成错误码"></a>跳转到友好错误页面，加上用户容易理解的错误提示信息。开放接口层要将异常处理成错误码</h4><h4 id="和错误信息方式返回。"><a href="#和错误信息方式返回。" class="headerlink" title="和错误信息方式返回。"></a>和错误信息方式返回。</h4><h4 id="3-【参考】分层领域模型规约："><a href="#3-【参考】分层领域模型规约：" class="headerlink" title="3. 【参考】分层领域模型规约："></a>3. 【参考】分层领域模型规约：</h4><p> DO（Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。  DTO（Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。  BO（Business Object）：业务对象。由Service层输出的封装业务逻辑的对象。  AO（Application Object）：应用对象。在Web层与Service层之间抽象的复用对象模型， 极为贴近展示层，复用度不高。  VO（View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。  Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止 使用Map类来传输。</p><h3 id="二-二方库依赖"><a href="#二-二方库依赖" class="headerlink" title="(二) 二方库依赖"></a>(二) 二方库依赖</h3><h4 id="1-【强制】定义GAV遵从以下规则："><a href="#1-【强制】定义GAV遵从以下规则：" class="headerlink" title="1. 【强制】定义GAV遵从以下规则："></a>1. 【强制】定义GAV遵从以下规则：</h4><p>1 ） GroupID格式：com.{公司&#x2F;BU }.业务线.[子业务线]，最多 4 级。 说明：{公司&#x2F;BU} 例如：alibaba&#x2F;taobao&#x2F;tmall&#x2F;aliexpress等BU一级；子业务线可选。 正例：com.taobao.jstorm 或 com.alibaba.dubbo.register 2 ） ArtifactID格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。 正例：dubbo-client &#x2F; fastjson-api &#x2F; jstorm-tool 3 ） Version：详细规定参考下方。</p><ol start="22"><li><p>【强制】二方库版本号命名方式：主版本号.次版本号.修订号1 ） 主版本号：产品方向改变，或者大规模API不兼容，或者架构不兼容升级。2 ） 次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的API不兼容修改。3 ） 修订号：保持完全兼容性，修复BUG、新增次要功能特性等。说明：注意起始版本号必须为：1.0.0，而不是0.0.1 正式发布的类库必须先去中央仓库进行查证，使版本号有延续性，正式版本号不允许覆盖升级。如当前版本：1.3.3，那么下一个合理的版本号：1.3.4 或 1.4.0 或 2.0.0 </p></li><li><p>【强制】线上应用不要依赖SNAPSHOT版本（安全包除外）。说明：不依赖SNAPSHOT版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。 </p></li><li><p>【强制】二方库的新增或升级，保持除功能点之外的其它jar包仲裁结果不变。如果有改变，必须明确评估和验证，建议进行dependency:resolve前后信息比对，如果仲裁结果完全不一致，那么通过dependency:tree命令，找出差异点，进行排除jar包。 </p></li><li><p>【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的POJO对象。 </p></li><li><p>【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。说明：依赖springframework-core,-context,-beans，它们都是同一个版本，可以定义一个变量来保存版本：${spring.version}，定义依赖的时候，引用该版本。 </p></li><li><p>【强制】禁止在子项目的pom依赖中出现相同的GroupId，相同的ArtifactId，但是不同的Version。说明：在本地调试时会使用各子项目指定的版本号，但是合并成一个war，只能有一个版本号出现在最后的lib目录中。可能出现线下调试是正确的，发布到线上却出故障的问题。 </p></li><li><p>【推荐】所有pom文件中的依赖声明放在语句块中，所有版本仲裁放在语句块中。说明：里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖，version和scope都读取自父pom。而所有声明在主pom的里的依赖都会自动引入，并默认被所有的子项目继承。 </p></li><li><p>【推荐】二方库不要有配置项，最低限度不要再增加配置项。 </p></li><li><p>【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：1 ）精简可控原则。移除一切不必要的API和依赖，只包含 Service API、必要的领域模型对象、Utils类、常量、枚举等。如果依赖其它二方库，尽量是provided引入，让二方库使用者去依赖具体版本号；无log具体实现，只依赖日志框架。2 ）稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。</p></li></ol><p> </p><h3 id="三-服务器"><a href="#三-服务器" class="headerlink" title="(三) 服务器"></a>(三) 服务器</h3><ol><li><p>【推荐】高并发服务器建议调小TCP协议的time_wait超时时间。说明：操作系统默认 240 秒后，才会关闭处于time_wait状态的连接，在高并发访问下，服务器端会因为处于time_wait的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。正例：在linux服务器上请通过变更&#x2F;etc&#x2F;sysctl.conf文件去修改该缺省值（秒）：net.ipv4.tcp_fin_timeout &#x3D; 30 </p></li><li><p>【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为fd）。说明：主流操作系统的设计是将TCP&#x2F;UDP连接采用与文件一样的方式去管理，即一个连接对应于一个fd。主流的linux服务器默认所支持最大fd数量为 1024 ，当并发连接数很大时很容易因为fd不足而出现“open too many files”错误，导致新的连接无法建立。 建议将linux服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。 </p></li><li><p>【推荐】给JVM设置-XX:+HeapDumpOnOutOfMemoryError参数，让JVM碰到OOM场景时输出dump信息。说明：OOM的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错非常有价值。 </p></li><li><p>【推荐】在线上生产环境，JVM的Xms和Xmx设置一样大小的内存容量，避免在GC 后调整堆大小带来的压力。 </p></li><li><p>【参考】服务器内部重定向使用forward；外部重定向地址使用URL拼装工具类来生成，否则会带来URL维护不一致的问题和潜在的安全风险。</p></li></ol><p> </p><h2 id="附-1-：版本历史"><a href="#附-1-：版本历史" class="headerlink" title="附 1 ：版本历史"></a>附 1 ：版本历史</h2><p>版本号 更新日期 备注</p><p>1.0.0 2017.2.9 阿里巴巴集团正式对外发布^ 1.0.1 2017.2. 13 1 ）修正String[]的前后矛盾。 2 ）vm修正成velocity。 3 ）修正countdown描述错误。</p><p>1.0.2 2017.2.20</p><p>1 ）去除文底水印。 2 ）数据类型中引用太阳系年龄问题。 3 ）修正关于异常和方法签名的部 分描述。 4 ）修正final描述。 5 ）去除Comparator部分描述。</p><p>1 .1.0 2017.2.27</p><p>1 ）增加前言。 2 ）增加&lt;? extends T&gt;描述和说明。 3 ）增加版本历史。 4 ）增加专有名词 解释。</p><p>1.1.1 2017.3.31 修正页码总数和部分示例。^</p><p>1.2.0 2017.5.20</p><p>1 ）根据云栖社区的“聚能聊”活动反馈，对手册的页码、排版、描述进行修正。 2 ）增加final 的适用场景描述。 3 ）增加关于锁的粒度的说明。 4 ）增加“指定集合大小”的详细说明以及 正反例。 5 ）增加卫语句的示例代码。 6 ）明确数据库表示删除概念的字段名为is_deleted</p><p>1.3.0 2017.9.25</p><p>增加单元测试规约（PDF终极版），阿里开源的IDE代码规约检测插件：点此下载 更多及时信息，请关注《阿里巴巴Java开发手册》官方公众号：</p><h2 id="附-2-：本手册专有名词"><a href="#附-2-：本手册专有名词" class="headerlink" title="附 2 ：本手册专有名词"></a>附 2 ：本手册专有名词</h2><ol><li><p>POJO（Plain Ordinary Java Object）: 在本手册中，POJO专指只有setter &#x2F; getter&#x2F; toString的简单类，包括DO&#x2F;DTO&#x2F;BO&#x2F;VO等。</p></li><li><p>GAV（GroupId、ArtifactctId、Version）: Maven坐标，是用来唯一标识jar包。</p></li><li><p>OOP（Object Oriented Programming）: 本手册泛指类、对象的编程处理方式。</p></li><li><p>ORM（Object Relation Mapping）: 对象关系映射，对象领域模型与底层数据之间的转换，本文泛指iBATIS, mybatis等框架。</p></li><li><p>NPE（java.lang.NullPointerException）: 空指针异常。</p></li><li><p>SOA（Service-Oriented Architecture）: 面向服务架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用，有利于提升组件可重用性，可维护性。</p></li><li><p>一方库: 本工程内部子项目模块依赖的库（jar包）。</p></li><li><p>二方库: 公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar包）。</p></li><li><p>三方库: 公司之外的开源库（jar包）。</p></li><li><p>IDE（Integrated Development Environment）: 用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具，本《手册》泛指IntelliJ IDEA和eclipse。</p></li></ol><p>法律声明 本手册为阿里巴巴集团技术部的技术分享，版权归阿里巴巴集团所有，仅供大家交流、学习及研究</p><h2 id="使用，禁止用于商业用途，违者必究。"><a href="#使用，禁止用于商业用途，违者必究。" class="headerlink" title="使用，禁止用于商业用途，违者必究。"></a>使用，禁止用于商业用途，违者必究。</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读《极客时间MySQL45讲》笔记</title>
      <link href="/2023/03/07/%E9%98%85%E8%AF%BB%E3%80%8A%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4MySQL45%E8%AE%B2%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/07/%E9%98%85%E8%AF%BB%E3%80%8A%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4MySQL45%E8%AE%B2%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="阅读-极客时间-MySQL45讲-笔记"><a href="#阅读-极客时间-MySQL45讲-笔记" class="headerlink" title="阅读 极客时间 MySQL45讲 笔记"></a>阅读 极客时间 MySQL45讲 笔记</h1><h1 id="1、基础架构"><a href="#1、基础架构" class="headerlink" title="1、基础架构"></a>1、基础架构</h1><h2 id="1-1-select-是如何运行的"><a href="#1-1-select-是如何运行的" class="headerlink" title="1.1 select 是如何运行的"></a>1.1 select 是如何运行的</h2><p><img src="1.png" alt="image"></p><p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p><p><img src="2.png" alt="image"></p><p>课后答案:分析器。Oracle会在分析阶段判断语句是否正确，表是否存在，列是否存在等。猜测MySQL也这样。</p><p><img src="3.png" alt="image"></p><p><img src="4.png" alt="image"></p><h2 id="1-2-update-语句是如何运行的"><a href="#1-2-update-语句是如何运行的" class="headerlink" title="1.2 update 语句是如何运行的"></a>1.2 update 语句是如何运行的</h2><p>例如：update t set age &#x3D; ‘15’ where id &#x3D; 15</p><p>mysql5.7 中存在查询缓存这一模块，所以一条 update 语句的运行顺序是：</p><p><em><strong>首先到连接器获取连接—》分析器分析语法是否正确，分析出这是一条更新语句—》查询缓存会把涉及到这张表的所有缓存删除—》优化器决定使用 id 这个索引—》执行器操作执行引擎返回结果</strong></em></p><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）。</p><h3 id="①、redo-log"><a href="#①、redo-log" class="headerlink" title="①、redo log"></a>①、redo log</h3><p>不知道你还记不记得《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。如果有人要赊账或者还账的话，掌柜一般有两种做法：</p><ul><li><p><em>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</em></p></li><li><p><em>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</em></p></li></ul><p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？</p><p>同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p><p>而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p><p>具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p><p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p><p><img src="5.png" alt="image"></p><p><img src="6.png" alt="image"></p><p><img src="7.png" alt="image"></p><h3 id="③、bin-log"><a href="#③、bin-log" class="headerlink" title="③、bin log"></a>③、bin log</h3><p>MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。</p><p><em><strong>这两种日志有以下三点不同。</strong></em></p><ul><li><p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p></li><li><p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</p></li><li><p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p></li></ul><p><strong>update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。</strong></p><p><img src="8.png" alt="image"></p><p><img src="9.png" alt="image"></p><p><img src="10.png" alt="image"></p><p><img src="11.png" alt="image"></p><h2 id="1-3、索引"><a href="#1-3、索引" class="headerlink" title="1.3、索引"></a>1.3、索引</h2><p><img src="12.png" alt="image"></p><p><img src="13.png" alt="image"></p><p><img src="14.png" alt="image"></p><p><img src="15.png" alt="image"></p><h2 id="1-4、锁"><a href="#1-4、锁" class="headerlink" title="1.4、锁"></a>1.4、锁</h2><p><img src="17.png" alt="image"></p><p><img src="16.png" alt="image"></p><p><img src="18.png" alt="image"></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可见性分析</title>
      <link href="/2023/03/06/%E5%8F%AF%E8%A7%81%E6%80%A7%E5%88%86%E6%9E%90/"/>
      <url>/2023/03/06/%E5%8F%AF%E8%A7%81%E6%80%A7%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="1.png" alt="image"></p>]]></content>
      
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简历</title>
      <link href="/2023/03/06/%E7%AE%80%E5%8E%86/"/>
      <url>/2023/03/06/%E7%AE%80%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="421a1b7d901eab2d5d10be344a8dd9d2f05ff030929d78c8043d214ef12ffe8f">c510d23e2365f5087e690aacf4bf2abb91e89123119fbd9537727b62f9faa6ed0b44345b5b3685c62a88a4d18f6f9cbf5c928b3db9931f73f01b8c1336c489d005013de41caa16c9e215bdf3ad0b22d0a656daec532133cb1dd140185698706c592293cfc246a803da936ed1aed316079fc5b81ad72c5c64d6d18919c73b780233918a880a414bfee840bbcd60b858100b3acd8e91e9fc1e01f4ca8a7c32054399a092302f2ed48c8a3aa5e911cf01eb986ea4890fa21bbdc550985540ad34c0152dfcdd80bfa86976fbda33830f6016d10b45bd5ccee2d8e80ec98fabf005aa324121774d3f3d8ef22e7ec5d73f8a122b4ec842af373dd8f559c32143e4dbae26b2040ce35ac1845c7ba503304f208cf3a60b36d97a586769222121a3715b3d9f0616a93657edf69979d96485ef3a7b2df79f53f6672646b7d038e5d076242d355a6c4dafe4b924aa50241259406166</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> yi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>aaaa</title>
      <link href="/2023/03/05/aaaa/"/>
      <url>/2023/03/05/aaaa/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><a class="tag-Link" target="_blank" href="https://developer.aliyun.com/article/769883">  <div class="tag-link-tips">引用站外地址</div>  <div class="tag-link-bottom">      <div class="tag-link-left" style="background-image: url(https://api.iowen.cn/favicon/developer.aliyun.com/article/769883.png);"></div>      <div class="tag-link-right">          <div class="tag-link-title">hello</div>          <div class="tag-link-sitename">hello</div>      </div>      <i class="fa-solid fa-angle-right"></i>  </div>  </a>]]></content>
      
      
      
        <tags>
            
            <tag> yi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读《深入理解Java虚拟机（第3版）》笔记</title>
      <link href="/2023/03/05/%E9%98%85%E8%AF%BB%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/05/%E9%98%85%E8%AF%BB%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="阅读《深入理解Java虚拟机（第3版）》笔记"><a href="#阅读《深入理解Java虚拟机（第3版）》笔记" class="headerlink" title="阅读《深入理解Java虚拟机（第3版）》笔记"></a>阅读《深入理解Java虚拟机（第3版）》笔记</h1><h1 id="JVM-架构图"><a href="#JVM-架构图" class="headerlink" title="JVM 架构图"></a>JVM 架构图</h1><h1 id><a href="#" class="headerlink" title></a><img src="1.png" alt="image"></h1><p><img src="2.png" alt="image"></p><h1 id="一、走进-Java"><a href="#一、走进-Java" class="headerlink" title="一、走进 Java"></a>一、走进 Java</h1><h2 id="1、Java-虚拟机家族"><a href="#1、Java-虚拟机家族" class="headerlink" title="1、Java 虚拟机家族"></a>1、Java 虚拟机家族</h2><h3 id="1-1、-武林盟主：HotSpot-VM"><a href="#1-1、-武林盟主：HotSpot-VM" class="headerlink" title="1.1、 武林盟主：HotSpot VM"></a>1.1、 武林盟主：HotSpot VM</h3><p>相信所有Java程序员都听说过HotSpot虚拟机，它是Sun&#x2F;OracleJDK和OpenJDK中的默认Java虚拟机，也是目前使用范围最广的Java虚拟机。但不一定所有人都知道的是，这个在今天看起来“血统纯正”的虚拟机在最初并非由Sun公司所开发，而是由一家名为“Longview Technologies”的小公司设计；甚至这个虚拟机最初并非是为Java语言而研发的，它来源于Strongtalk虚拟机，而这款虚拟机中相当多的技术又是来源于一款为支持Self语言实现“达到C语言50%以上的执行效率”的目标而设计的Self虚拟机，最终甚至可以追溯到20世纪80年代中期开发的Berkeley Smalltalk上。Sun公司注意到这款虚拟机在即时编译等多个方面有着优秀的理念和实际成果，在1997年收购了Longview Technologies公司，从而获得了HotSpot虚拟机。</p><p>HotSpot虚拟机的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知即时编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准即时编译和栈上替换编译（On-Stack Replacement，OSR）行为 。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更复杂的代码优化技术，输出质量更高的本地代码。</p><h2 id="2、展望Java技术的未来"><a href="#2、展望Java技术的未来" class="headerlink" title="2、展望Java技术的未来"></a>2、展望Java技术的未来</h2><h3 id="1-1-向Native迈进"><a href="#1-1-向Native迈进" class="headerlink" title="1.1　向Native迈进"></a>1.1　向Native迈进</h3><p>在微服务架构的视角下，应用拆分后，单个微服务很可能就不再需要面对数十、数百GB乃至TB的内存，有了高可用的服务集群，也无须追求单个服务要7×24小时不间断地运行，它们随时可以中断和更新；但相应地，Java的启动时间相对较长，需要预热才能达到最高性能等特点就显得相悖于这样的应用场景。在无服务架构中，矛盾则可能会更加突出，比起服务，一个函数的规模通常会更小，执行时间会更短，当前最热门的无服务运行环境AWS Lambda所允许的最长运行时间仅有15分钟。</p><p>直到Substrate VM出现，才算是满足了人们心中对Java提前编译的全部期待。Substrate VM是在Graal VM 0.20版本里新出现的一个极小型的运行时环境，包括了独立的异常处理、同步调度、线程管理、内存管理（垃圾收集）和JNI访问等组件，目标是代替HotSpot用来支持提前编译后的程序执行。它还包含了一个本地镜像的构造器（Native Image Generator），用于为用户程序建立基于Substrate VM的本地运行时镜像。这个构造器采用指针分析（Points-To Analysis）技术，从用户提供的程序入口出发，搜索所有可达的代码。在搜索的同时，它还将执行初始化代码，并在最终生成可执行文件时，将已初始化的堆保存至一个堆快照之中。这样一来，Substrate VM就可以直接从目标程序开始运行，而无须重复进行Java虚拟机的初始化过程。但相应地，原理上也决定了Substrate VM必须要求目标程序是完全封闭的，即不能动态加载其他编译器不可知的代码和类库。基于这个假设，Substrate VM才能探索整个编译空间，并通过静态分析推算出所有虚方法调用的目标方法。</p><p><img src="3.png" alt="image"></p><p>Substrate VM补全了Graal VM“Run Programs Faster Anywhere”愿景蓝图里的最后一块拼图，让Graal VM支持其他语言时不会有重量级的运行负担。譬如运行JavaScript代码，Node.js的V8引擎执行效率非常高，但即使是最简单的HelloWorld，它也要使用约20MB的内存，而运行在Substrate VM上的Graal.js，跑一个HelloWorld则只需要4.2MB内存，且运行速度与V8持平。Substrate VM的轻量特性，使得它十分适合嵌入其他系统，譬如Oracle自家的数据库就已经开始使用这种方式支持用不同的语言代替PL&#x2F;SQL来编写存储过程 。</p><h1 id="二、自动内存管理"><a href="#二、自动内存管理" class="headerlink" title="二、自动内存管理"></a>二、自动内存管理</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>对于从事C、C++程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的“皇帝”，又是从事最基础工作的劳动人民——既拥有每一个对象的“所有权”，又担负着每一个对象生命从开始到终结的维护责任。</p><p>对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete&#x2F;free代码，不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把控制内存的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误、修正问题将会成为一项异常艰难的工作。</p><h2 id="2、运行时数据区域"><a href="#2、运行时数据区域" class="headerlink" title="2、运行时数据区域"></a>2、运行时数据区域</h2><p>这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p><p><img src="4.png" alt="image"></p><h3 id="2-1、程序计数器"><a href="#2-1、程序计数器" class="headerlink" title="2.1、程序计数器"></a>2.1、程序计数器</h3><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里  ，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</p><h3 id="2-2、Java虚拟机栈"><a href="#2-2、Java虚拟机栈" class="headerlink" title="2.2、Java虚拟机栈"></a>2.2、Java虚拟机栈</h3><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧 （Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>经常有人把Java内存区域笼统地划分为堆内存（Heap）和栈内存（Stack），这种划分方式直接继承自传统的C、C++程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比这更复杂。不过这种划分方式的流行也间接说明了程序员最关注的、与对象内存分配关系最密切的区域是“堆”和“栈”两块。其中，“堆”在稍后笔者会专门讲述，而“栈”通常就是指这里讲的虚拟机栈，或者更多的情况下只是指虚拟机栈中局部变量表部分。</p><p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p><p>在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展 ，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p><h3 id="2-3、本地方法栈"><a href="#2-3、本地方法栈" class="headerlink" title="2.3、本地方法栈"></a>2.3、本地方法栈</h3><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p><h3 id="2-4、Java堆"><a href="#2-4、Java堆" class="headerlink" title="2.4、Java堆"></a>2.4、Java堆</h3><p>对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。在《Java虚拟机规范》中对Java堆的描述是：“所有的对象实例以及数组都应当在堆上分配  ”，而这里笔者写的“几乎”是指从实现角度来看，随着Java语言的发展，现在已经能看到些许迹象表明日后可能出现值类型的支持，即使只考虑现在，由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换  优化手段已经导致一些微妙的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。</p><p>Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空间”“To Survivor空间”等名词，这些概念在本书后续章节中还会反复登场亮相，在这里笔者想先说明的是这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。不少资料上经常写着类似于“Java虚拟机的堆内存分为新生代、老年代、永久代、Eden、Survivor……”这样的内容。在十年之前（以G1收集器的出现为分界），作为业界绝对主流的HotSpot虚拟机，它内部的垃圾收集器全部都基于“经典分代”  来设计，需要新生代、老年代收集器搭配才能工作，在这种背景下，上述说法还算是不会产生太大歧义。但是到了今天，垃圾收集器技术与十年前已不可同日而语，HotSpot里面也出现了不采用分代设计的新垃圾收集器，再按照上面的提法就有很多需要商榷的地方了。</p><p>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java堆中的上述各个区域的分配、回收等细节将会是下一章的主题。</p><p>根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。</p><p>Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。</p><h3 id="2-5、方法区"><a href="#2-5、方法区" class="headerlink" title="2.5、方法区"></a>2.5、方法区</h3><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区分开来。</p><p>说到方法区，不得不提一下“永久代”这个概念，尤其是在JDK 8以前，许多Java程序员都习惯在HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。</p><h3 id="2-6、运行时常量池"><a href="#2-6、运行时常量池" class="headerlink" title="2.6、运行时常量池"></a>2.6、运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><h4 id="2-6-1、常量池-class-常量池"><a href="#2-6-1、常量池-class-常量池" class="headerlink" title="2.6.1、常量池(class 常量池)"></a>2.6.1、常量池(class 常量池)</h4><p><img src="5.png" alt="image"></p><h4 id="2-6-2、运行时常量池"><a href="#2-6-2、运行时常量池" class="headerlink" title="2.6.2、运行时常量池"></a>2.6.2、运行时常量池</h4><p>运行时常量池是方法区的一部分。运行时常量池是当Class文件被加载到内存后，Java虚拟机会 将Class文件常量池里的内容转移到运行时常量池里(运行时常量池也是每个类都有一个)。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中</p><p>方法区的Class文件信息，Class常量池和运行时常量池的三者关系</p><p><img src="6.png" alt="image"></p><h4 id="2-6-3、字符串常量池"><a href="#2-6-3、字符串常量池" class="headerlink" title="2.6.3、字符串常量池"></a>2.6.3、字符串常量池</h4><p>字符串常量池又称为：字符串池，全局字符串池,英文也叫String Pool。 在工作中，String类是我们使用频率非常高的一种对象类型。JVM为了提升性能和减少内存开销，避免字符串的重复创建，其维护了一块特殊的内存空间，这就是我们今天要讨论的核心：字符串常量池。字符串常量池由String类私有的维护。</p><p>++<em><strong>*在JDK7之前字符串常量池是在永久代里边的，但是在JDK7之后，把字符串常量池分进了堆里边。</strong></em>++</p><p>代码演示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 黄熠丹 221231005</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Intern_test</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/1/18 10:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Intern_test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 在堆里创建对象 “abc”</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="comment">/*调用native方法 判断堆中的字符串常量池中是否存在 “abc”</span></span><br><span class="line"><span class="comment">        如果存在直接返回，不存在则创建*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">intern</span> <span class="operator">=</span> str.intern();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(intern == str);<span class="comment">//false</span></span><br><span class="line">        System.out.println(intern == s);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Java虚拟机对于Class文件每一部分（自然也包括常量池）的格式都有严格规定，如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池，《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h3 id="2-7、直接内存"><a href="#2-7、直接内存" class="headerlink" title="2.7、直接内存"></a>2.7、直接内存</h3><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。</p><p>在JDK 1.4中新加入了NIO（New Input&#x2F;Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p><h2 id="3、HotSpot虚拟机对象探秘"><a href="#3、HotSpot虚拟机对象探秘" class="headerlink" title="3、HotSpot虚拟机对象探秘"></a>3、HotSpot虚拟机对象探秘</h2><h3 id="3-1、对象的创建"><a href="#3-1、对象的创建" class="headerlink" title="3.1、对象的创建"></a>3.1、对象的创建</h3><p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程，本书第7章将探讨这部分细节。</p><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定（如何确定将在2.3.2节中介绍），为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump The Pointer）。但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上 就只能采用较为复杂的空闲列表来分配内存。</p><p>除如何划分可用空间之外，还有另外一个需要考虑的问题：对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种可选方案：一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+&#x2F;-UseTLAB参数来设定。</p><p>内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</p><p>接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。关于对象头的具体内容，稍后会详细介绍。</p><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始——构造函数，即Class文件中的<init>()方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说（由字节码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），new指令之后会接着执行<init>()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</init></init></p><p><strong>HotSpot解释器代码片段</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确保常量池中存放的是已解释的类</span></span><br><span class="line"><span class="keyword">if</span> (!constants-&gt;tag_at(index).is_unresolved_klass()) &#123;</span><br><span class="line">    <span class="comment">// 断言确保是klassOop和instanceKlassOop（这部分下一节介绍）</span></span><br><span class="line">    <span class="type">oop</span> <span class="variable">entry</span> <span class="operator">=</span> (klassOop) *constants-&gt;obj_at_addr(index);</span><br><span class="line">    <span class="keyword">assert</span>(entry-&gt;is_klass(), <span class="string">&quot;Should be resolved klass&quot;</span>);</span><br><span class="line">    <span class="type">klassOop</span> <span class="variable">k_entry</span> <span class="operator">=</span> (klassOop) entry;</span><br><span class="line">    <span class="keyword">assert</span>(k_entry-&gt;klass_part()-&gt;oop_is_instance(), <span class="string">&quot;Should be instanceKlass&quot;</span>);</span><br><span class="line">    instanceKlass* ik = (instanceKlass*) k_entry-&gt;klass_part();</span><br><span class="line">    <span class="comment">// 确保对象所属类型已经经过初始化阶段</span></span><br><span class="line">    <span class="keyword">if</span> ( ik-&gt;is_initialized() &amp;&amp; ik-&gt;can_be_fastpath_allocated() ) &#123;</span><br><span class="line">        <span class="comment">// 取对象长度</span></span><br><span class="line">        <span class="type">size_t</span> <span class="variable">obj_size</span> <span class="operator">=</span> ik-&gt;size_helper();</span><br><span class="line">        <span class="type">oop</span> <span class="variable">result</span> <span class="operator">=</span> NULL;</span><br><span class="line">        <span class="comment">// 记录是否需要将对象所有字段置零值</span></span><br><span class="line">        <span class="type">bool</span> <span class="variable">need_zero</span> <span class="operator">=</span> !ZeroTLAB;</span><br><span class="line">        <span class="comment">// 是否在TLAB中分配对象</span></span><br><span class="line">        <span class="keyword">if</span> (UseTLAB) &#123;</span><br><span class="line">            result = (oop) THREAD-&gt;tlab().allocate(obj_size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result == NULL) &#123;</span><br><span class="line">            need_zero = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 直接在eden中分配对象</span></span><br><span class="line">retry:</span><br><span class="line">            HeapWord* compare_to = *Universe::heap()-&gt;top_addr();</span><br><span class="line">            HeapWord* new_top = compare_to + obj_size;</span><br><span class="line">            <span class="comment">// cmpxchg是x86中的CAS指令，这里是一个C++方法，通过CAS方式分配空间，并发失败的</span></span><br><span class="line">               话，转到retry中重试直至成功分配为止</span><br><span class="line">            <span class="keyword">if</span> (new_top &lt;= *Universe::heap()-&gt;end_addr()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Atomic::cmpxchg_ptr(new_top, Universe::heap()-&gt;top_addr(), compare_to) != compare_to) &#123;</span><br><span class="line">                    goto retry;</span><br><span class="line">                &#125;</span><br><span class="line">                result = (oop) compare_to;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result != NULL) &#123;</span><br><span class="line">            <span class="comment">// 如果需要，为对象初始化零值</span></span><br><span class="line">            <span class="keyword">if</span> (need_zero ) &#123;</span><br><span class="line">                HeapWord* to_zero = (HeapWord*) result + sizeof(oopDesc) / oopSize;</span><br><span class="line">                obj_size -= sizeof(oopDesc) / oopSize;</span><br><span class="line">                <span class="keyword">if</span> (obj_size &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    memset(to_zero, <span class="number">0</span>, obj_size * HeapWordSize);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据是否启用偏向锁，设置对象头信息</span></span><br><span class="line">            <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">                result-&gt;set_mark(ik-&gt;prototype_header());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result-&gt;set_mark(markOopDesc::prototype());</span><br><span class="line">            &#125;</span><br><span class="line">            result-&gt;set_klass_gap(<span class="number">0</span>);</span><br><span class="line">            result-&gt;set_klass(k_entry);</span><br><span class="line">            <span class="comment">// 将对象引用入栈，继续执行下一条指令</span></span><br><span class="line">            SET_STACK_OBJECT(result, <span class="number">0</span>);</span><br><span class="line">            UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、对象的内存布局"><a href="#3-2、对象的内存布局" class="headerlink" title="3.2、对象的内存布局"></a>3.2、对象的内存布局</h3><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><p>HotSpot虚拟机对象的对象头部分包括两类信息。第一类是用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称它为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向) 下对象的存储内容如表2-1所示。</p><p><img src="7.png" alt="image"></p><p>对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，这点我们会在下一节具体讨论。此外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。</p><p>代码清单2-2为HotSpot虚拟机代表Mark Word中的代码（markOop.cpp）注释片段，它描述了32位虚拟机Mark Word的存储布局：</p><p>代码清单2-2　markOop.cpp片段</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bit-format of an object header (most significant first, big endian layout below):</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  32 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//  hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//  size:32 ------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//  PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br></pre></td></tr></table></figure><p>接下来实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配顺序为longs&#x2F;doubles、ints、shorts&#x2F;chars、bytes&#x2F;booleans、oops（Ordinary Object Pointers，OOPs），从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果HotSpot虚拟机的+XX：CompactFields参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。</p><p>对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h3 id="3-3、-对象的访问定位"><a href="#3-3、-对象的访问定位" class="headerlink" title="3.3、 对象的访问定位"></a>3.3、 对象的访问定位</h3><p>创建对象自然是为了后续使用该对象，我们的Java程序会通过栈上的reference数据来操作堆上的具体对象。由于reference类型在《Java虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有使用句柄和直接指针两种：</p><p>·如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，其结构如图2-2所示。</p><p>·如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销，如图2-3所示。</p><p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><p><img src="8.png" alt="image"></p><p><img src="9.png" alt="image"></p><p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就本书讨论的主要虚拟机HotSpot而言，它主要使用第二种方式进行对象访问（有例外情况，如果使用了Shenandoah收集器的话也会有一次额外的转发，具体可参见第3章），但从整个软件开发的范围来看，在各种语言、框架中使用句柄来访问的情况也十分常见。</p><h2 id="4、实战：OutOfMemoryError异常"><a href="#4、实战：OutOfMemoryError异常" class="headerlink" title="4、实战：OutOfMemoryError异常"></a>4、实战：OutOfMemoryError异常</h2><p><strong>在《Java虚拟机规范》的规定里，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError（下文称OOM）异常的可能，</strong>本节将通过若干实例来验证异常实际发生的代码场景（代码清单2-3～2-9），并且将初步介绍若干最基本的与自动内存管理子系统相关的HotSpot虚拟机参数。</p><h3 id="4-1、Java堆溢出"><a href="#4-1、Java堆溢出" class="headerlink" title="4.1、Java堆溢出"></a>4.1、Java堆溢出</h3><p>Java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。</p><p>代码清单2-3中限制Java堆的大小为20MB，不可扩展（将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数-XX：+HeapDumpOnOutOf-MemoryError可以让虚拟机在出现内存溢出异常的时候Dump出当前的内存堆转储快照以便进行事后分析 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 黄熠丹 221231005</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 堆溢出演示</span></span><br><span class="line"><span class="comment"> * VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/1/18 14:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOverflow_test</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            List&lt;OOMObject&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">OOMObject</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错截图</p><p><img src="10.png" alt="image"></p><h3 id="4-2、虚拟机栈和本地方法栈溢出"><a href="#4-2、虚拟机栈和本地方法栈溢出" class="headerlink" title="4.2、虚拟机栈和本地方法栈溢出"></a>4.2、虚拟机栈和本地方法栈溢出</h3><p>由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数（设置本地方法栈大小）虽然存在，但实际上是没有任何效果的，栈容量只能由-Xss参数来设定。关于虚拟机栈和本地方法栈，在《Java虚拟机规范》中描述了两种异常：·</p><p>1）如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</p><p>2）如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。</p><p>《Java虚拟机规范》明确允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机的选择是不支持扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常。</p><h3 id="4-3、方法区和运行时常量池溢出"><a href="#4-3、方法区和运行时常量池溢出" class="headerlink" title="4.3、方法区和运行时常量池溢出"></a>4.3、方法区和运行时常量池溢出</h3><p>在JDK 8以后，永久代便完全退出了历史舞台，元空间作为其替代者登场。在默认设置下，前面列举的那些正常的动态创建新类型的测试用例已经很难再迫使虚拟机产生方法区的溢出异常了。不过为了让使用者有预防实际应用里出现类似于代码清单2-9那样的破坏性的操作，HotSpot还是提供了一些参数作为元空间的防御措施，主要包括：</p><p>·-XX：MaxMetaspaceSize：设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存大小。</p><p>·-XX：MetaspaceSize：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过-XX：MaxMetaspaceSize（如果设置了的话）的情况下，适当提高该值。</p><p>·-XX：MinMetaspaceFreeRatio：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。类似的还有-XX：Max-MetaspaceFreeRatio，用于控制最大的元空间剩余容量的百分比。</p><h3 id="4-4、本机直接内存溢出"><a href="#4-4、本机直接内存溢出" class="headerlink" title="4.4、本机直接内存溢出"></a>4.4、本机直接内存溢出</h3><p>直接内存（Direct Memory）的容量大小可通过-XX：MaxDirectMemorySize参数来指定，如果不去指定，则默认与Java堆最大值（由-Xmx指定）一致。</p><p>由直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况，如果读者发现内存溢出之后产生的Dump文件很小，而程序中又直接或间接使用了DirectMemory（典型的间接使用就是NIO），那就可以考虑重点检查一下直接内存方面的原因了。</p><h1 id="三、垃圾收集器与内存分配策略"><a href="#三、垃圾收集器与内存分配策略" class="headerlink" title="三、垃圾收集器与内存分配策略"></a>三、垃圾收集器与内存分配策略</h1><h2 id="1、对象已死？"><a href="#1、对象已死？" class="headerlink" title="1、对象已死？"></a>1、对象已死？</h2><p>在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（“死去”即不可能再被任何途径使用的对象）了。</p><h3 id="1-1、引用计算法"><a href="#1-1、引用计算法" class="headerlink" title="1.1、引用计算法"></a>1.1、引用计算法</h3><p>很多教科书判断对象是否存活的算法是这样的：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。笔者面试过很多应届生和一些有多年工作经验的开发人员，他们对于这个问题给予的都是这个答案。</p><p>测试Java虚拟机是否是通过引用计算法回收</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 黄熠丹 221231005</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 引用计数算法的缺陷 testGC()方法执行后，objA和objB会不会被GC呢？</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/1/18 15:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testGC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="literal">null</span>;</span><br><span class="line">        objB = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设在这行发生GC，objA和objB是否能被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        testGC();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出 log 后发现确实进行了垃圾回收，意味着虚拟机并没有因为这两个对象互相引用就放弃回收它们，证实了 java 虚拟机不是通过引用计数法来回收垃圾。日志截图如下。</p><p><img src="11.png" alt="image"></p><h3 id="1-2、可达性分析算法"><a href="#1-2、可达性分析算法" class="headerlink" title="1.2、可达性分析算法"></a>1.2、可达性分析算法</h3><p>当前主流的商用程序语言Java的内存管理子系统，都是通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p><p>如图3-1所示，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的，因此它们将会被判定为可回收的对象。</p><p><img src="12.png" alt="image"></p><p>在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：</p><p>1、在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</p><p><img src="13.png" alt="image"></p><p>2、在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</p><p><img src="14.png" alt="image"></p><p>·在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</p><p>·在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</p><p>·Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</p><p>·所有被同步锁（synchronized关键字）持有的对象。</p><p>·反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p><p><img src="15.png" alt="image"></p><h3 id="1-3、再谈引用"><a href="#1-3、再谈引用" class="headerlink" title="1.3、再谈引用"></a>1.3、再谈引用</h3><p>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p><p>·强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj&#x3D;new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p><p>·软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</p><p>·弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</p><p>·虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</p><h3 id="1-4、生存还是死亡"><a href="#1-4、生存还是死亡" class="headerlink" title="1.4、生存还是死亡"></a>1.4、生存还是死亡</h3><p>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</p><p>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。从代码清单3-2中我们可以看到一个对象的finalize()被执行，但是它仍然可以存活。</p><p>代码演示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 黄熠丹 221231005</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 此代码演示了两点：</span></span><br><span class="line"><span class="comment"> *               1.对象可以在被GC时自我拯救。</span></span><br><span class="line"><span class="comment"> *               2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/1/18 10:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">FinalizeEscapeGC</span> <span class="variable">SAVE_HOOK</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isAlive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yes, i am still alive :)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize method executed!&quot;</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> <span class="title class_">FinalizeEscapeGC</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="literal">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, i am dead :(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="literal">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, i am dead :(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><p><img src="16.png" alt="image"></p><p><strong>第一次执行成功第二次失败，因为 finalize()方法只会被执行一次。</strong></p><p>另外一个值得注意的地方就是，代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败了。这是因为任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。</p><h2 id="2、垃圾收集算法"><a href="#2、垃圾收集算法" class="headerlink" title="2、垃圾收集算法"></a>2、垃圾收集算法</h2><h3 id="2-1、分代收集理论"><a href="#2-1、分代收集理论" class="headerlink" title="2.1、分代收集理论"></a>2.1、分代收集理论</h3><p>当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（Generational Collection） <a href="https://www.neat-reader.cn/text00061.html#ch1_back">^[1]^</a> 的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：</p><p>1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</p><p>2）强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</p><p>3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</p><p><strong>2.2、标记-清除算法</strong></p><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p><p>它的主要缺点有两个：第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><p><img src="17.png" alt="image"></p><h3 id="2-3、标记-复制算法"><a href="#2-3、标记-复制算法" class="headerlink" title="2.3、标记-复制算法"></a>2.3、标记-复制算法</h3><p>标记-复制算法常被简称为复制算法。为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，1969年Fenichel提出了一种称为“半区复制”（Semispace Copying）的垃圾收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一点。</p><p><img src="18.png" alt="image"></p><p>现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代，IBM公司曾有一项专门研究对新生代“朝生夕灭”的特点做了更量化的诠释——新生代中的对象有98%熬不过第一轮收集。因此并不需要按照1∶1的比例来划分新生代的内存空间。</p><p>在1989年，Andrew Appel针对具备“朝生夕灭”特点的对象，提出了一种更优化的半区复制分代策略，现在称为“Appel式回收”。HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局 。Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。当然，98%的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，因此Appel式回收还有一个充当罕见情况的“逃生门”的安全设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。</p><h3 id="2-4、-标记-整理算法"><a href="#2-4、-标记-整理算法" class="headerlink" title="2.4、 标记-整理算法"></a>2.4、 标记-整理算法</h3><p>标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>针对老年代对象的存亡特征，1974年Edward Lueders提出了另外一种有针对性的“标记-整理”（Mark-Compact）算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存，“标记-整理”算法的示意图如图3-4所示。</p><p><img src="19.png" alt="image"></p><p>如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行，这就更加让使用者不得不小心翼翼地权衡其弊端了，像这样的停顿被最初的虚拟机设计者形象地描述为“Stop The World”。</p><p>但如果跟标记-清除算法那样完全不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。譬如通过“分区空闲分配链表”来解决内存分配问题（计算机硬盘存储大文件就不要求物理连续的磁盘空间，能够在碎片化的硬盘上存储和访问就是通过硬盘分区表实现的）。内存的访问是用户程序最频繁的操作，甚至都没有之一，假如在这个环节上增加了额外的负担，势必会直接影响应用程序的吞吐量。</p><p>基于以上两点，是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。此语境中，吞吐量的实质是赋值器（Mutator，可以理解为使用垃圾收集的用户程序，本书为便于理解，多数地方用“用户程序”或“用户线程”代替）与收集器的效率总和。即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要高得多，这部分的耗时增加，总吞吐量仍然是下降的。HotSpot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的，这也从侧面印证这点。</p><h2 id="3、HotSpot的算法细节实现"><a href="#3、HotSpot的算法细节实现" class="headerlink" title="3、HotSpot的算法细节实现"></a>3、HotSpot的算法细节实现</h2><h3 id="3-1、根节点枚举"><a href="#3-1、根节点枚举" class="headerlink" title="3.1、根节点枚举"></a>3.1、根节点枚举</h3><p>我们以可达性分析算法中从GC Roots集合找引用链这个操作作为介绍虚拟机高效实现的第一个例子。固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，尽管目标明确，但查找过程要做到高效并非一件容易的事情，现在Java应用越做越庞大，光是方法区的大小就常有数百上千兆，里面的类、常量等更是恒河沙数，若要逐个检查以这里为起源的引用肯定得消耗不少时间。</p><p>由于目前主流Java虚拟机使用的都是准确式垃圾收集（这个概念在第1章介绍Exact VM相对于Classic VM的改进时介绍过），所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。在HotSpot的解决方案里，是使用一组称为OopMap的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译（见第11章）过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。</p><h3 id="3-2、安全点"><a href="#3-2、安全点" class="headerlink" title="3.2、安全点"></a>3.2、安全点</h3><p>在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说导致OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。</p><p>实际上HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置被称为安全点（Safepoint）。有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。因此，安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的，因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这样的原因而长时间执行，“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。</p><p>对于安全点，另外一个需要考虑的问题是，如何在垃圾收集发生时让所有线程（这里其实不包括执行JNI调用的线程）都跑到最近的安全点，然后停顿下来。这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension），抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。</p><p>而主动式中断的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。</p><p>由于轮询操作在代码中会频繁出现，这要求它必须足够高效。HotSpot使用内存保护陷阱的方式，把轮询操作精简至只有一条汇编指令的程度。下面代码清单3-4中的test指令就是HotSpot生成的轮询指令，当需要暂停用户线程时，虚拟机把0x160100的内存页设置为不可读，那线程执行到test指令时就会产生一个自陷异常信号，然后在预先注册的异常处理器中挂起线程实现等待，这样仅通过一条汇编指令便完成安全点轮询和触发线程中断了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
